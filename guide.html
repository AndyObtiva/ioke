<!DOCTYPE html 
PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Ioke &raquo; Programming Guide</title>
    <link rel="stylesheet" href="style/ioke-style.css" type="text/css" media="screen" />
  </head>
  <body>
    <div id="logo">
      <a href="index.html">
        <img src="img/IokeLogo.png" alt="Ioke Logo" width="118" height="115" border="0"/>
      </a>
    </div>

    <div id="header">
      Programming Guide
    </div>

    <div id="content">
    <table cellpadding="0" cellspacing="0" border="0">
      <tr>
        <td valign="top" style="background: #E6EEEE;">
            <table cellpadding="0" cellspacing="0" border="0" id="menu">
              <tr>
                <td>
                  <span class="menuItem">
                    <a href="index.html" class="unselectedMenuItem">About Ioke</a>
                  </span>
                </td>
              </tr>
              <tr>
                <td style="height:.4em"></td>
              </tr>

              <tr>
                <td>
                  <span class="menuItem">
                    <a href="guide.html" class="selectedMenuItem">Guide</a>
                  </span>
                </td>
              </tr>
              <tr>
                <td style="height:.4em"></td>
              </tr>

              <tr>
                <td>
                  <span class="menuItem">
                    <a href="download.html" class="unselectedMenuItem">Download</a>
                  </span>
                </td>
              </tr>
              <tr>
                <td style="height:.4em"></td>
              </tr>

              <tr>
                <td>
                  <span class="menuItem">
                    <a href="http://ioke.kenai.com" class="unselectedMenuItem">Project page</a>
                  </span>
                </td>
              </tr>
              <tr>
                <td style="height:.4em"></td>
              </tr>

              <tr>
                <td>
                  <span class="menuItem">
                    <a href="dok/index.html" class="unselectedMenuItem">Reference</a>
                  </span>
                </td>
              </tr>
              <tr>
                <td style="height:.4em"></td>
              </tr>
            </table>
        </td>
        <td>
          <table cellpadding="0" cellspacing="0" border="0" style="width:50em">
            <tr>
              <td style="width:10em"></td>
              <td>
                <ol>
                  <li>
                    <a href="#introduction">Introduction</a>
                    <ol>
                      <li>
                        <a href="#vision">Vision</a>
                      </li>
                      <li>
                        <a href="#gettingStarted">Getting started</a>
                        <ol>
                          <li>
                            <a href="#runningScripts">Running scripts</a>
                          </li>
                          <li>
                            <a href="#interactive">Interactive mode</a>
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#syntax">Syntax</a>
                    <ol>
                      <li>
                        <a href="#literals">Literal values</a>
                        <ol>
                          <li>
                            <a href="#literalText">Text</a>
                          </li>
                          <li>
                            <a href="#literalRegexps">Regular expressions</a>
                          </li>
                          <li>
                            <a href="#literalIntegers">Integers</a>
                          </li>
                          <li>
                            <a href="#literalDecimals">Decimals</a>
                          </li>
                          <li>
                            <a href="#literalSymbols">Symbols</a>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <a href="#operatorShuffling">Operator shuffling</a>
                      </li>
                      <li>
                        <a href="#assignmentShuffling">Assignment shuffling</a>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#executionModel">Execution model</a>
                  </li>

                  <li>
                    <a href="#objects">Objects</a>
                    <ol>
                      <li>
                        <a href="#base">Base</a>
                      </li>
                      <li>
                        <a href="#ground">Ground</a>
                      </li>
                      <li>
                        <a href="#origin">Origin</a>
                      </li>
                      <li>
                        <a href="#defaultBehavior">DefaultBehavior</a>
                      </li>
                      <li>
                        <a href="#nilTrueFalse">nil, true, false</a>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#assignment">Assignment</a>
                  </li>

                  <li>
                    <a href="#controlFlow">Control flow</a>
                    <ol>
                      <li>
                        <a href="#comparison">Comparison</a>
                      </li>
                      <li>
                        <a href="#conditionals">Conditionals</a>
                      </li>
                      <li>
                        <a href="#iteration">Iteration</a>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#code">Code</a>
                    <ol>
                      <li>
                        <a href="#methods">Methods</a>
                      </li>
                      <li>
                        <a href="#macros">Macros</a>
                      </li>
                      <li>
                        <a href="#blocks">Blocks</a>
                      </li>
                      <li>
                        <a href="#messageChains">Message chains</a>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#introspection">Introspection and reflection</a>
                  </li>

                  <li>
                    <a href="#importing">Importing</a>
                  </li>

                  <li>
                    <a href="#coreKinds">Core kinds</a>
                    <ol>
                      <li>
                        <a href="#conditions">Conditions</a>
                      </li>
                      <li>
                        <a href="#text">Text</a>
                      </li>
                      <li>
                        <a href="#numbers">Numbers</a>
                      </li>
                      <li>
                        <a href="#lists">Lists</a>
                      </li>
                      <li>
                        <a href="#dicts">Dicts</a>
                      </li>
                      <li>
                        <a href="#rangesAndPairs">Ranges and Pairs</a>
                      </li>
                      <li>
                        <a href="#enumerable">Enumerable</a>
                      </li>
                      <li>
                        <a href="#regexps">Regexps</a>
                      </li>
                      <li>
                        <a href="#filesystem">FileSystem</a>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#libraries">Libraries</a>
                    <ol>
                      <li>
                        <a href="#iik">IIk</a>
                      </li>
                      <li>
                        <a href="#ispec">ISpec</a>
                      </li>
                      <li>
                        <a href="#dokgen">DokGen</a>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <a href="#missing">What is missing</a>
                  </li>
                  <li>
                    <a href="#futurePlans">Future plans</a>
                  </li>
                </ol>

                <hr/>

                <div class="chapter">
                  <h2><a name="introduction">Introduction</a></h2>
                  <p>Ioke is a general purpose language. It is a strongly typed, extremely dynamic, prototype object oriented language. It is homoiconic and it's closest ancestors is Io, Smalltalk, Ruby and Lisp - but it's quite a distance from all of them. It looks a lot like Io, to a limit.</p>

                  <p>Ioke is targeted at the Java Virtual Machine and is tightly integrated with the platform. Why the JVM? It's available everywhere, it gives severeal important features such as world class garbage collectors, capable thread schedulers and an amazing JIT compiler. All of these are things that server Ioke well, without requiring direct development resources from the Ioke team. Access to the Java platform also means access to all existing libraries and functionality, with all that entails. The JVM is just a very pragmatic choice.</p>

                  <p>You're probably reading this guide at <a href="http://ioke.org/guide.html">ioke.org</a>. That is the official home of the project, although some of the project functionality is hosted at <a href="http://ioke.kenai.org">Kenai</a>, where such things as mailing lists and a bug tracker is available. The canonical source repository for Ioke exists at GitHub, at <a href="http://github.org/olabini/ioke/tree/master">http://github.org/olabini/ioke/tree/master</a>.</p>

                  <p>The current version of Ioke is called Ioke 0. The naming of Ioke will change regularily with major revisions. There are two different versions in play here. Ioke 0 is the name and version of the language and core libraries. The initial implementation for Ioke 0 is called ikJVM 0.1.0, and the version numbers are not interdependent. The next major version of Ioke will be called Ioke S, and you can find information about it in the chapter on <a href="#futurePlans">future plans</a>.</p>

                  <p>This programming guide -- together with the reference for your current version -- should be the complete document needed to understand Ioke 0, how to program in it, how to understand the names and concepts used, and also to give an initial inkling on what I think is good taste.</p>

                  <p>Note that I will use many names that aren't necessarily the same as the ones traditional programming languages use. These names will be made clear sooner or later in this document, but it might help some to jump forward to <a href="#objects">Objects</a>, skim that bit, and then start over once words like Origin, cell and mimic make sense.</p>

                  <div class="section">
                    <h3><a name="vision">Vision</a></h3>

                    <p>The evolution of programming languages is a steady progression of finding new ways to express abstractions naturally - in a way that doesn't stray to far away from the smaller details. A programming language have to make it possible to abstract a way common things, while making it easy to customize these abstractions in very detailed ways. A programming language should be able to do this well without sacrificing readability and understandability. This tension lies at the core of programming.</p>

                    <p>How do you create a language that makes it easy to express powerful concepts in a succinct way, while still making it easy to maintain and work with after the fact, without turning it into a new compression mode? How do make it easy for a programmer to express high level abstractions that are abstractions of abstractions of abstractions?</p>

                    <p>There are many open problems in programming language design. Concurrency is one of them, performance another. These are two areas Ioke does not address. Instead, Ioke is a remodeling of the core concepts and ideas embodied in other programming languages.</p>

                    <p>Are still Lisp and Smalltalk the most powerful languages around, or are there ways of providing more expressiveness without sacrificing understandability? Is there a way to combine all the lessons learned from languages like Ruby and Python, and patch them back into a Lisp and Smalltalk core? Is it possible to do this while taking some of the benefits of Io? Can a language be both small, regular, homoiconic, reflective and easy to understand? I hope that Ioke is just that.</p>

                    <p>Simplicity doesn't mean lack of power. Small, simple, orthogonal functionality can be more powerful than larger, complicated abstractions that doesn't fit together.</p>

                    <p>Io explicitly states that the goal of the language is to refocus attention on expressiveness, and with Ioke I want to take that philosophy one step further.</p>

                    <p>It's important to realize that an experiment like this doesn't necessarily have to mean the language can't be used for real projects. By wedding Ioke to the Java Virtual Machine, I make it easy to get access to good libraries and existing implementations on most platforms. In that way, Ioke can be used to create real systems, even though the ecosystem will initially be very small. And I think that this is necessary. How can you know if a language really is worthwhile or not, if you can't use it as a general purpose programming language? The Java platform makes this possible.</p>
                  </div>

                  <div class="section">
                    <h3><a name="gettingStarted">Getting started</a></h3>
                    <p>Ioke is very easy to get started with. The first step is to download a package. Which one you choose depends on what platform you're on, and whether you want to build Ioke yourself, or just start using it. This guide will only cover using a prebuilt version. Go to the download page at <a href="http://ioke.org/download.html">http://ioke.org/download.html</a>, and download one of the distributions. At the time of writing the full version of Ioke is Ioke 0 ikJVM 0.1.0. Choose the latest download in the 0.1-series for this document to apply. In later revisions of the document, any major change will be noted inline.</p>

                    <p>Once you have downloaded the distribution, you need to unpack it somewhere, and finally add the bin-directory to your PATH environment variable. There is also a jar-download that can be run directly. If you choose this option you don't get the benefits of having a home for Ioke, which in some cases be inconvenient. Ioke can be run directly from the jar-file, though.</p>

                    <div class="section">
                      <h4><a name="runningScripts">Running scripts</a></h4>
                      <p>To run an Ioke script, you can generally just use the ioke-command:</p>
                      <pre class="code">
$ ioke helloWorld.ik
Hello world</pre>

                      <p>You can also execute snippets of code on the command line using the -e argument to the ioke-command. You can have several of these one the same line too:</p>

                      <pre class="code">
$ ioke -e'"Hello world" println' -e'"Goodbye world" println'
Hello world
Goodbye world</pre>

                      <p>When using -e, be careful about what quoting style you use, since the shell sometimes can munge up your commands if you don't surround them correctly.</p>
                      <p>The ioke command has several helpful command line options, that can change what happens during execution. These are:</p>
                      <dl>
                        <dt>-Cdirectory</dt>
                        <dd>Switch to directory before executing any files and command line scripts. This will make the directory the initial current working directory for Ioke during the execution of the JVM.</dd>

                        <dt>-d</dt>
                        <dd>Enable debug output.</dd>

                        <dt>-e script</dt>
                        <dd>Execute script, as describe above. May occur more than once on a command line.</dd>

                        <dt>-h</dt>
                        <dt>--help</dt>
                        <dd>Display help information, including descriptions of these command line options.</dd>

                        <dt>-Idirectory</dt>
                        <dd>Add directory to the load path of Ioke. May occur more than once on a command line.</dd>

                        <dt>-JjvmOptions</dt>
                        <dd>Pass on options to the JVM. This can be used to change any runtime parameters that your JVM takes. May occur more than once. The options are provided directly after the -J, so if you want to change the maximum amount of memory used, you can do that writing -J-Xmx128M. </dd>

                        <dt>--copyright</dt>
                        <dd>Print copyright information and exit.</dd>

                        <dt>--version</dt>
                        <dd>Print version information and exit</dd>

                        <dt>--server</dt>
                        <dd>Run the JVM in server Hotspot mode</dd>

                        <dt>--client</dt>
                        <dd>Run the JVM in client Hotspot mode (the default)</dd>

                        <dt>--</dt>
                        <dd>Mark the end of options to the ioke script, anything after this is options that will be sent to the code running.</dd>
                      </dl>

                      <p>If you provide the name of a script file on the command line, it should come after all the arguments to the ioke script. Everything after the script will be added as data to the 'System programArguments' cell. You can use both one-line scripts with -e and specify a script file. If so, the script file will be run after the one-line scripts.</p>
                    </div>

                    <div class="section">
                      <h4><a name="interactive">Interactive mode</a></h4>

                      <p>If no code to execute has been specified to the ioke script, IIk - Interactive Ioke - will start. This is a REPL that allow the execution of arbitrary code at a shell that immediately displays the result. The main difference between running Ioke from a file and interactively, is that the interactive prompt will show a notice of the result of the last operation, after each execution. IIk will also invoke a debugger when a condition is encountered. This debugger gives you the possibility to closer inspect what happened. The final difference with IIk is that it does not execute code directly in Ground - which the top level inside an Ioke script will do. This difference is crucial, when considering namespacing issues.</p>

                      <p>IIk will try to use Readline through JLine if your platform supports it.</p>

                      <p>IIk will be more closely described in the section on it, <a href="#iik">here</a>, but just to give a glimpse, this is how a small session could look like:</p>
                      <pre class="code">
iik> "hello world" println
hello world
+> nil

iik> 10 * 20
+> 200

iik> 3/2
+> 3/2

iik> 3/2 + 3/2
+> 3

iik> 3/2 * 3    
+> 9/2

iik> foo = "hello"
+> "hello"

iik> foo
+> "hello"

iik> exit
Bye.</pre>

                      <p>When you see the prompt "iik>", you know that IIk is waiting for input. The result of a computation is shown after the "+>" sigil. You can exit from IIk by calling either "exit" or "quit". There is also a restart named "quit" that can be invoked to quit IIk.</p>
                    </div>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="syntax">Syntax</a></h2>

                  <p>Ioke has no keywords or statements. Everything is an expression composed of a chain of messages. A piece of code is represented as a chain of messages that links to the next message. The result of one message will be the receiver of the next message, until a "." message is received. The "." message is a terminator that throws away the current receiver. A newline will serve as a "." message in the circumstances where it feels natural.</p>

                  <p>An informal BNF description of Ioke looks like this:</p>
                  <pre style="font-family: courier;">
    program       ::=  messageChain*
    messageChain  ::=  expression*
    expression    ::=  message | brackets | operator | literal | terminator
    message       ::=  Identifier ( "(" commated? ")" )?
    commated      ::=  expression+ ( "," expression+ )*
    brackets      ::=  ( "[" commated? "]" ) | ( "{" commated? "}" )
    literal       ::=  Text | Regexp | Number | Decimal
    terminator    ::=  "." | "\n"
    comment       ::=  ";" .* "\n"</pre>

                  <p>What isn't visible here is that all whitespace -- except for newlines -- will work only as separators of messages, and is otherwise ignored. That means that message sending does not use the dot, as in most other languages. A phrase such as "foo().bar(quux(42)).baaz()" would be expressed as "foo() bar(quux(42)) baaz()", or more succinctly "foo bar(quux(42)) baaz" in Ioke.</p>

                  <p>All the types of literals are actually turned into a message to create that literal, so the canonical form of the message chain contains no literals, just a message to create that literal. Any message can have zero or more arguments given to it. Arguments are separated with comma. If there are no arguments to a message, the parenthesis can be left off, but they need to be there if there are arguments. Mostly any combination of characters can be used as an Identifier, with some exceptions.</p>

                  <p>There is also a syntactic element called operators, which are handled a bit differently from regular messages. Specifically, through the use of operator shuffling, operators can be used in infix, including having different precedence rules. Assignment is a specific form of operator which gets its own kind of shuffling. These are both described below.</p>

                  <p>The two forms of brackets will get turned into a canonical form. Surrounding comma-separated message chains with square brackets is the same as calling the method [], giving it those message chains as argument. So [foo, bar, quux] is exactly the same as [](foo, bar, quux). The same is true for curly brackets.</p>

                  <p>Comments start with semicolon and end at the first newline. They can be used mostly anywhere, except inside of literal texts. The hash sign followed by an exclamation mark is also a comment, to allow the shebang line in Unix scripts.</p>

                  <p>How and when the actual evaluation of messages happen depend on what kind the message type is. If it's inactive, the value reflecting that cell will be returned. If it's active, the cell will be activated and the result of that activation returned. How the activation depends on what kind of code the cell contains. The various kinds of code is described more closely in the chapter about <a href="#code">code</a>.</p>

                  <div class="section">
                    <h3><a name="literals">Literal values</a></h3>
                    <p>Ioke currently contains four different kinds of literals. There is a fifth quasi literal, that isn't exactly parsed as a literal, but will be evaluated differently based on its name. These literals are texts, regular expressions, integers and decimal numbers. Symbols are actually parsed as regular identifiers, but they are handled a bit differently during evaluation.</p>

                    <div class="section">
                      <h4><a name="literalText">Text</a></h4>
                      <p>A literal text in Ioke is what is generally called strings in most languages. As in most languages, text is written inside of double quotes. Any characters are valid inside of those double quotes. That includes newlines - so you can write a literal text that extends to several lines. There is no alternate syntax for text. As in most other languages, several escapes are valid inside of a text. Escapes are preceded by the backslash, and insert the character corresponding to the escape values. These escapes are:</p>

                      <dl>
                        <dt>\b</dt>
                        <dd>Inserts the bell character, that is represented in ASCII by the decimal value 8.</dd>

                        <dt>\e</dt>
                        <dd>Inserts the character that is represented in ASCII by the decimal value 27. This value is used for sending escape values to the TTYs in some operating systems.</dd>

                        <dt>\t</dt>
                        <dd>Inserts the TAB character - ASCII decimal 9.</dd>

                        <dt>\n</dt>
                        <dd>Inserts the newline character - ASCII decimal 10.</dd>

                        <dt>\f</dt>
                        <dd>Inserts the form feed character - ASCII decimal 12.</dd>

                        <dt>\r</dt>
                        <dd>Inserts the carriage return character - ASCII decimal 13.</dd>

                        <dt>\"</dt>
                        <dd>Inserts the double quote character - ASCII decimal 34.</dd>

                        <dt>\\</dt>
                        <dd>Inserts the backslash character - ASCII decimal 92.</dd>

                        <dt>\[newline]</dt>
                        <dd>Inserts nothing at all. Used to escape necessary newlines, without having them show up in the output text.</dd>

                        <dt>\#</dt>
                        <dd>Inserts a literal hash character - ASCII decimal 35.</dd>

                        <dt>\uABCD</dt>
                        <dd>Inserts the Unicode codepoint corresponding to the hexadecimal value of the four characters following the "u". All four hexadecimal characters need to be specified.</dd>

                        <dt>\7, \12, \316</dt>
                        <dd>Inserts the Unicode codepoint corresponding to the octal value of the one, two or three octal characters. The maximum value allowed is \377, and the minimum is obviously \0.</dd>
                      </dl>

                      <p>The parsing of text will generate a message with name "internal:createText". This message will get one argument that is the raw Java String corresponding to the text.</p>

                      <p>Ioke allows automatic interpolation of arbitrary values in the same manner as Ruby. It uses the same syntax for this, which is the #{} syntax inside a text. These can be nested in any way. The elements will be parsed and sent as arguments to the message with name "internal:concatenateText". So an Ioke text such as "foo bar#{flux} will #{1+2}" will generate the message internal:concatenateText("foo bar", flux, " will ", 1+(2), ""). As you can see, there is a small amount of waste in the way this is generated -- but the simple model makes it easy to understand. It's not guaranteed that this will remain the same, although the message will definitely remain.</p>

                      <p>Some examples:</p>
                      <pre class="code">
<span style="color: #0050a0;">"foo"</span>

<span style="color: #0050a0;">"flax \
mux"</span>

<span style="color: #0050a0;">"one two #{three} \b four"</span></pre>
                    </div>

                    <div class="section">
                      <h4><a name="literalRegexps">Regular expressions</a></h4>
                      <p>The regular expression syntax of Ioke is currently quite primitive, although the literal syntax is there. A literal regular expression in Ioke starts with a hash sign, a slash, the expression, a slash, and possibly some flags. A few examples might be in order here:</p>
                      <pre class="code">
<span style="color: #ff1493;">#//</span>

<span style="color: #ff1493;">#/foo/</span>

<span style="color: #ff1493;">#/fo+/x</span></pre>

                      <p>The first example is an empty regular expression. The second is an expression matching the word "foo". The third expression matches an "f" followed with one or more "o". It also allows extended regular expression syntax, due to the x flag. The flags supported in Ioke are o, x, p, n, i, u, m and s. The meaning of these match the meaning of corresponding Ruby flags. Regular expressions allow most of the same escapes as Ioke text. Specifically, these escapes are supported: b, t, n, f, r, /, \ and newline. Unicode and octal escapes also work.</p>

                      <p>Ioke regular expressions will be transformed into a call to internal:createRegexp. This message expects two Java strings, one with the actual pattern, and one with the flags.</p>
                    </div>

                    <div class="section">
                      <h4><a name="literalIntegers">Integers</a></h4>
                      <p>Ioke supports arbitrarily sized numbers. It also contains a numerical tower that can be more closely explored in the reference documentation. The numerical tower is based in Number. Number Real mimics Number. Number Rational mimics Number Real, and so does Number Decimal. Finally, Number Integer and Number Ratio both mimics Number Rational. The interesting parts of this tower is Number Integer, which corresponds to integers, Number Ratio, which is any ratio between two integers, and Number Decimal, which corresponds to decimal numbers. These are arbitrarily sized and exact. There are no floats or doubles in Ioke. There is also a potential place for Number Complex at the same layer as Number Real, although complex numbers are not currently implemented. There are also plans for implementing a unit system further down the line.</p>

                      <p>Literal integers can be written using either decimal or hexadecimal notation. Hexadecimal notation begins with 0x or 0X and are then followed by one or more hexadecimal letters. They can be either upper or lower case. A decimal literal number is written using one or more decimal letters, but nothing else.</p>

                      <p>There is no literal to create ratios - these can only be created by division of integers. Negative numbers have no literal syntax, but preceding a number with a minus sign will call the message - on the number and generate the negative value.</p>

                      <p>A literal integer will be transformed into a call to internal:createNumber, which takes one native Java String from which to create the number.</p>

                      <p>Some examples:</p>
                      <pre class="code">
<span style="color: #0050a0;">1234444444444444444444444444444444444444235234534534</span>

<span style="color: #0050a0;">0</span>

<span style="color: #0050a0;">0xFFFFF</span></pre>
                    </div>

                    <div class="section">
                      <h4><a name="literalDecimals">Decimals</a></h4>
                      <p>Literal decimal values can be written either using exponential notation, or using a decimal dot. A decimal dot notation can be combined with exponential notation. Exponential notation starts with a number or a decimal number, followed by lower or upper case E, followed by an optional sign, and then followed by one or more decimal letters. </p>

                      <p>A literal decimal will be transformed into a call to internal:createDecimal, which takes one native Java String from which to create the decimal.</p>

                      <p>Some examples:</p>
                      <pre class="code">
<span style="color: #0050a0;">0.0</span>

<span style="color: #0050a0;">1E6</span>

<span style="color: #0050a0;">1E-32</span>

<span style="color: #0050a0;">23.4445e10</span></pre>
                    </div>

                    <div class="section">
                      <h4><a name="literalSymbols">Symbols</a></h4>
                      <p>Symbols aren't exactly syntax, but they aren't exactly messages either. Or rather, they are messages that will evaluate to the symbol that represent themselves. Symbol is a kind in Ioke. There are two kinds of symbols - the first one is simple symbols that can be parsed as is. The second is symbols that can't be parsed as is. Symbols are preceeded by a colon and then directly followed by the symbol text. If it can't be parsed correctly, the value should be surrounded by quotes, and this will be turned into a call to the method :, which takes the text as argument. That means that you can actually get dynamic symbols by calling the : method.</p>

                      <p>Some examples:</p>
                      <pre class="code">
<span style="color: #7777d4;">:foo</span>

<span style="color: #7777d4;">:flaxBarFoo</span>

<span style="color: #7777d4;">:""</span>

<span style="color: #7777d4;">:"mux mex mox \n ::::::::"</span></pre>
                    </div>
                  </div>

                  <div class="section">
                    <h3><a name="operatorShuffling">Operator shuffling</a></h3>
                    <p>One exception to the way message handling works in Ioke is operators. All the so called operators in this section is possible to call directly in message passing position too -- but to make it possible to use them in a more natural way, the parsing step will handle them a bit differently, and then do a shuffling step that actually takes operator precedence into account. So all the common operators will generally work as you expect them too -- although I recommend adding parenthesis when something is possibly unclear.</p>
                    
                    <p>Ioke has a slightly larger amount of operators than most other languages. Most of these are currently unused, but they are certainly available for use for any purpose the programmer wants to use it for. Many adherents of other languages (Java, I'm looking at you) claim that operator overloading is evil. I don't believe that is true, seeing as how it works so well in Ruby, so Ioke instead allow you quite large freedom with regards to operators.</p>

                    <p>The precedence rules for regular operators can be found in the cell 'Message OperatorTable operators', which is a regular Dict that can be updated with new values. The new values will obviously not take effect until the current code has run, and a new parse is started.</p>

                    <p>At the time of writing, the available operators are these:</p>

                    <ul>
                      <li>&lt;=&gt;</li>
                      <li>&lt;=</li>
                      <li>&gt;=</li>
                      <li>&lt;</li>
                      <li>&gt;</li>
                      <li>===</li>
                      <li>==</li>
                      <li>!=</li>
                      <li>=~</li>
                      <li>!~</li>
                      <li>-</li>
                      <li>+</li>
                      <li>**</li>
                      <li>*</li>
                      <li>/</li>
                      <li>%</li>
                      <li>&amp;&amp;</li>
                      <li>&amp;</li>
                      <li>||</li>
                      <li>|</li>
                      <li>^</li>
                      <li>=&gt;</li>
                      <li>=&gt;&gt;</li>
                      <li>&lt;-&gt;</li>
                      <li>-&gt;</li>
                      <li>+&gt;</li>
                      <li>!&gt;</li>
                      <li>&lt;&gt;</li>
                      <li>&amp;&gt;</li>
                      <li>%&gt;</li>
                      <li>#&gt;</li>
                      <li>@&gt;</li>
                      <li>/&gt;</li>
                      <li>*&gt;</li>
                      <li>?&gt;</li>
                      <li>|&gt;</li>
                      <li>^&gt;</li>
                      <li>~&gt;</li>
                      <li>**&gt;</li>
                      <li>&amp;&amp;&gt;</li>
                      <li>||&gt;</li>
                      <li>$&gt;</li>
                      <li>-&gt;&gt;</li>
                      <li>+&gt;&gt;</li>
                      <li>!&gt;&gt;</li>
                      <li>&lt;&gt;&gt;</li>
                      <li>&amp;&gt;&gt;</li>
                      <li>%&gt;&gt;</li>
                      <li>#&gt;&gt;</li>
                      <li>@&gt;&gt;</li>
                      <li>/&gt;&gt;</li>
                      <li>*&gt;&gt;</li>
                      <li>?&gt;&gt;</li>
                      <li>&gt;&gt;</li>
                      <li>^&gt;&gt;</li>
                      <li>~&gt;&gt;</li>
                      <li>**&gt;&gt;</li>
                      <li>&amp;&amp;&gt;&gt;</li>
                      <li>||&gt;&gt;</li>
                      <li>$&gt;&gt;</li>
                      <li>...</li>
                      <li>..</li>
                      <li>&lt;&lt;</li>
                      <li>&gt;&gt;</li>
                      <li>or</li>
                      <li>nor</li>
                      <li>xor</li>
                      <li>and</li>
                      <li>nand</li>
                      <li>!</li>
                      <li>~</li>
                      <li>$</li>
                    </ul>

                    <p>And as mentioned above, all of these can be used for your own purpose, although some of them already have reserved meanings. This document will cover most of the used operators, while the rest can be found in the reference.</p>

                    <p>Since this operator shuffling happens, that also means that an Ioke program has a canonical inner form that can differ from the source text. When you use introspection of any kind, you will get back that canonical form which might not look exactly like you expected. Similarily, if you ask some code to print itself, it will use the canonical form instead of the operator skin. Macros that modify message chains should work against the canonical form, and nothing else.</p>

                    <p>What an operator does depends on the result of sending the message of that name to the receiver, just like regular messages. In fact, to Ioke there really isn't any difference, except that the parsing takes special notice about operators and assignment operators.</p>
                  </div>

                  <div class="section">
                    <h3><a name="assignmentShuffling">Assignment shuffling</a></h3>
                    <p>Much like with regular operators, assignment operators are subject to a kind of shuffling. This shuffling differs from regular operator shuffling, in that it will shuffle around two things - the left hand side and the right hand side. This is true for every assignment operator except for the unary ones, which will only reshuffle one message.</p>

                    <p>A few examples might make the translation easier to percieve. The first item is the readable form, while the second form is the canonical form:</p>
                    <pre class="code">
<span style="color: #b0c4de;">foo</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">1</span> <span style="color: #00bfff;">+</span> <span style="color: #0050a0;">2</span>
<span style="color: #00bfff;">=</span>(foo<span style="color: #006666;">,</span> <span style="color: #0050a0;">1</span> <span style="color: #00bfff;">+</span>(<span style="color: #0050a0;">2</span>))

<span style="color: #8b0000;">Ground</span> <span style="color: #b0c4de;">foo</span> <span style="color: #00bfff;">*=</span> <span style="color: #0050a0;">"text"</span>
<span style="color: #b0c4de;">Ground</span> <span style="color: #00bfff;">*=</span>(foo<span style="color: #006666;">,</span> <span style="color: #0050a0;">"text"</span>)

bar foo(<span style="color: #0050a0;">123</span>) <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
<span style="color: #b0c4de;">bar</span> <span style="color: #00bfff;">=</span>(foo(<span style="color: #0050a0;">123</span>)<span style="color: #006666;">,</span> <span style="color: #0050a0;">42</span>)

flux<span style="color: #00bfff;">++</span>
<span style="color: #00bfff;">++</span>(flux)</pre>

                    <p>These examples show some more advanced details -- specifically the fact that assignment operators generally work on "places", not on names or cells. This will be more explored in the chapter on <a href="#assignment">assignment</a>. The important thing to notice from the above examples is that for most assignments two things will be rearranged. For the unary operators only one thing will be moved.</p>

                    <p>Just as with regular operators, the assignment operators have information in the 'Message OperatorTable' cell. The specific cell is 'Message OperatorTable assignOperators', and it matches an assignment operator to either the integer 1, or the integer 2. Everything with 1 will be matched as being unary assignment.</p>

                    <p>The currently available assignment operators are:</p>

                    <ul>
                      <li>=</li>
                      <li>++</li>
                      <li>--</li>
                      <li>+=</li>
                      <li>-=</li>
                      <li>/=</li>
                      <li>**=</li>
                      <li>*=</li>
                      <li>%=</li>
                      <li>&amp;=</li>
                      <li>&amp;&amp;=</li>
                      <li>|=</li>
                      <li>||=</li>
                      <li>^=</li>
                      <li>&lt;&lt;=</li>
                      <li>&gt;&gt;=</li>
                    </ul>

                    <p>Just as with regular operators, what an assignment operator does depend on what the result is from sending the message of that name to the receiver object, just like with any type of message.</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="executionModel">Execution model</a></h2>
                  <p>The way an Ioke program work is very simple. Everything executes based on two things. The first is the context, or the ground, and the second is the receiver. The first message sent in each message chain will have the ground as receiver. The default ground in Ioke source files is an object called Ground. This object is in the mimic chain for most regular objects created in Ioke, which means that things defined at the top level will generally be available in most objects. Inside of methods and blocks, the ground will be different. Exactly in what way is defined by the type of code executing.</p>

                  <p>Every message in a chain will be sent to the receiver of that message. That receiver is the result of the last message, or the current ground if there was no previous message, or if that previous message was a terminator. So Ioke code like "foo bar(flux bar) quux" involves 5 different messages.</p>

                  <ol>
                    <li><p>The message "foo" is sent to Ground, which is the current ground and also the default receiver.</p></li>
                    <li><p>The message "bar" is sent to the result of the "foo" message. The value returned will be activated.</p></li>
                    <li><p>The cell "bar" contains a method in this case, and that method expects one argument, so that forces evaluation of the arguments.</p></li>
                    <li><p>The message "flux" is sent to Ground, since it's the ground and there is no prior message inside of an argument list.</p></li>
                    <li><p>The message "bar" is sent to the result of the "flux" message.</p></li>
                    <li><p>The result of the "bar" message is used as the argument value given to the outside "bar" method.</p></li>
                    <li><p>The message "quux" is sent to the result of the initial "bar" message.</p></li>
                    <li><p>The result of the quux message is thrown away, unless this code is part of a larger piece of code.</p></li>
                  </ol>

                  <p>This description generally describes what happens in the case of this code. The more general control flow is this:</p>

                  <ol>
                    <li><p>A message is encountered</p></li>
                    <li><p>If the message is a symbol message, the corresponding symbol will be returned.</p></li>
                    <li><p>Otherwise the name of the message will be looked up in the receiver, or in the receivers mimics.</p></li>
                    <li><p>If the name is found and is not activatable, the value of that name (the cell) is returned.</p></li>
                    <li><p>If the name is found and is activatable, it will be activated, with the current ground, receiver and message sent to the activatable object.</p></li>
                    <li><p>If the name is not found, a second search is done for the name "pass". If a pass is found, use that instead of the name of the original message, and go back to 4.</p></li>
                    <li><p>If a pass is not found, signal a Condition Error NoSuchCell condition.</p></li>
                  </ol>

                  <p>Exactly what happens when an object is activated depends on what kind of code gets activated. It's really up to the method, block or macro to handle evaluation of arguments in any way it likes - including not evaluating them. For a description of the default models available, see the chapter on <a href="#code">code</a></p>
                </div>

                <div class="chapter">
                  <h2><a name="objects">Objects</a></h2>
                  <p>The object model of Ioke is quite simple. Everything in Ioke is an object that follow these same rules. An object is something with an identity. It can have zero or more mimics, and zero or more cells. An object can also have a documentation text. Some objects can have a native data component. This acts more or less like a hidden cell that contains information that can't be directly represented in Ioke - for example the actual text in a Text. Or the actual number in a Number. Or the actual regular expression in a Regexp. These objects are the core types that contain primitive information.</p>
                  <p>A cell is the main way of representing data in Ioke. A cell has a name and a value. Every value in Ioke is a cell - every time you send a message, a cell is looked up for the value of that cell. Cells can contain any kind of data. In other languages, cells are generally called properties or slots. They are quite close to instance variables that also can contain methods. Cells can be added and removed at any time during runtime.</p>

                  <p>A mimic could also be called the parent of the object. Ioke is a prototype based language, which means that there is no distinction between classes of objects, and the objects themselves. In fact, any object can be used as the class of a new object. The word for that is mimicking, since the word class loses it's meaning in this kind of language. It's most common for an object to mimic one other object, at least initially. It's impossible to create an object that doesn't mimic anything, but you can remove all mimics for an object after the fact. You can also add more mimics. This turns out to be useful to represent shared functionality in the manner of Ruby mixins, for example. The actual effect of a mimic is that when a cell can't be found in the current object, all mimics will be searched for that cell (depth-first). So all cells available in an objects mimic is available to the object too. This is the inheritance part of OOP.</p>

                  <p>In many places you will find the word Kind used. A Kind is by convention an object that is used primarily to use as a mimic for other objects. The convention is that kinds are named with an initial upper case letter, while everything else starts with a lower case letter. The assignment process of Ioke also uses this convention to automatically set a cell called "kind" on any object that gets assigned to a name matching this convention.</p>

                  <p>The rest of this chapter will discuss the kinds that are the basis of the object system.</p>

                  <div class="section">
                    <h3><a name="base">Base</a></h3>

                    <p>The kind called Base is the top of the mimic chain. It's not generally useful in itself as it only defines the bare minimum of cells to make it possible to add new cells to it, mimic it, and so on. But if you want an object that is possible to use but not include most of the other stuff, Base is place to begin. Be careful when defining methods in Base, since it doesn't have access to most of the namespace. In fact, it doesn't even know about its own name. Base can act as a kind of blank slate, if needed, but it's probably easier to just create a regular object and remove all mimics from it after the fact.</p>

                    <p>Base defines these cells:</p>
                    <dl>
                      <dt>kind</dt>
                      <dd>returns the kind of the object, which is "Base".</dd>

                      <dt>notice</dt>
                      <dd>returns the short notice of the object, which is "Base". Refer to <a href="#introspection">Introspection</a> for more information about notice.</dd>

                      <dt>=</dt>
                      <dd>Takes two values, the first a place and the second a value, and assigns the place named to that value. Refer to <a href="#assignment">Assignment</a> for more information about it.</dd>

                      <dt>==</dt>
                      <dd>Compares this object against the argument. Returns true if they are the same, otherwise false.</dd>

                      <dt>cell</dt>
                      <dd>Takes one argument that should be the name of a cell that exists, and returns the value of the cell unactivated.</dd>

                      <dt>cell=</dt>
                      <dd>Sets a cell to a specific value. Used to set cells that can't be set using the regular assignment model. Refer to <a href="#assignment">Assignment</a> for more information about it.</dd>

                      <dt>cell?</dt>
                      <dd>Takes one argument that should be the name of a cell to check if it exists in this objects mimic chain.</dd>

                      <dt>cellNames</dt>
                      <dd>Returns a List containing the names of all cells this object contains.</dd>

                      <dt>cells</dt>
                      <dd>Returns a Dict with all cells this object contains. The key is the name and the value is the cell value.</dd>

                      <dt>documentation</dt>
                      <dd>Returns the documentation text for this object, or nil if no documentation exists for it.</dd>

                      <dt>documentation=</dt>
                      <dd>Sets the documentation text for this object.</dd>

                      <dt>mimic</dt>
                      <dd>Returns a newly created object that has the receiver as mimic. This is the magic way of creation new objects in Ioke. It is also the <em>ONLY</em> way to do it.</dd>
                    </dl>

                    <p>All of these methods are described further in the reference.</p>
                  </div>

                  <div class="section">
                    <h3><a name="ground">Ground</a></h3>
                    <p>As mentioned above, Ground is the default ground/context for evaluation. Ground mimics Base and DefaultBehavior. Ground is also special in that this is the place where all top level kinds are defined. If you want to create a top level kind, you should put it in Ground. If you take a look in Ground, you will see that it contains cells for Text, Dict, List, Base, Origin, itself and many other. Ioke doesn't have any global state at all, but Ground is as close as it gets. Ground should in most cases not be mimicked directly.</p>
                  </div>

                  <div class="section">
                    <h3><a name="origin">Origin</a></h3>
                    <p>Origin should be the place where most objects in Ioke start from. It is specifically created to be the origin of objects. As such it doesn't contain many cells for itself, but it mimics Ground and has access to everything from Base, DefaultBehavior and Ground in that way. When adding new more or less global functionality, Origin is probably the best place to put it. Currently, the only cells Origin contains is for purposes of printing itself.</p>
                  </div>

                  <div class="section">
                    <h3><a name="defaultBehavior">DefaultBehavior</a></h3>
                    <p>DefaultBehavior is a mixin - meaning it should never be the sole mimic of an object. Mixins are generally not grounded in Base, and doesn't contain most of the things you would expect from an object. DefaultBehavior contain almost all the general methods you use when programming Ioke. It contains the internal methods to create values from literals, and most other functionality specified in this document. In short, DefaultBehavior is the work horse, and you should have a pretty good reason to not have it in the mimic chain of an object. Since Ground mimics DefaultBehavior, any object you create from Origin, will have DefaultBehavior in its mimic chain.</p>
                  </div>

                  <div class="section">
                    <h3><a name="nilTrueFalse">nil, true, false</a></h3>
                    <p>The three values nil, true and false are the only values that are considered kinds, even though they start with lower case letters. They are not like the other kinds in the other important way either - these values can not be mimicked, and you will get a condition if you try it. The reason is that Ioke's basic boolean system revolves around these values. It is not entirely certrain that these values will forever be the only boolean values, but for now they are. nil should be used to represent the absence of a value, including the absence of a reasonable return value. false is the quintessential false value, and true is the quintessential true value. The value true isn't strictly necessary since any value except for nil and false are true. This notion of truthness mimics Ruby. The cells nil, true and false are defined in Ground, and they can actually be overridden or changed - but I don't recommend it. I can guarantee lots of chaos and non-working programs from doing it. More info on how these values interact can be found in the section on <a href="#comparison">Comparison</a>.</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="assignment">Assignment</a></h2>
                  <p>Superficially, Ioke's assignment model is quite simple. But there exists some subtleties too. One of the main reasons for this is that assigning a cell that doesn't exist will create that cell. Where it gets created is different based on what kind of context the assignment happens in. The main difference here is between a method activation context, or a lexical block context.</p>

                  <p>Ioke also supports assignment of places, which makes assigning much more flexible. A third feature of Ioke assignment is that it will check for the existence of an assignment method before assigning a specific name. This chapter will make all these things clear, and show some examples.</p>

                  <p>Let's start with a small example of simple assignment:</p>
                  <pre class="code">
<span style="color: #0000cd;">foo</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
foo <span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
foo <span style="color: #b0c4de;">y</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">13</span>
foo <span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">+=</span> <span style="color: #0050a0;">2</span></pre>

                  <p>The first line creates a new Origin mimic, and then assigns that to the name foo. Since this code executes at the top level, "foo" will be a new cell created in Ground. The second line creates a new cell called "x" inside the "foo" object. It gets assigned the value 42. The third line creates a "y" cell, and the fourth line sends the += message, which will first call +, and then assign using =. So at the end of this program, "foo" will contain two cells: "x" with value 44, and "y" with value 13. As mentioned above, cells gets created the first time they are assigned to. If you need to create a cell in a specific object, just namespace it. For example, if you want to make sure that you create a cell in Ground, just do "Ground foo = 42".</p>

                  <p>Inside of a method, the situation is exactly the same. If you assign something, it will be assigned in the current context, which is the local activation context (meaning it's the place where local variables are available). There are two situations where this doesn't hold true. The first one is within the special method "do". This method will take any code as argument and execute that with the receiver of the "do" message as the ground/context of the code inside it. That means "do" is a good way to create new cells inside an object.</p>

                  <p>This is a bit academic, so lets take a look at an example of this:</p>
                  <pre class="code">
<span style="color: #0000cd;">Foo</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
<span style="color: #606060;">Foo</span> <span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(
  <span style="color: #a52a2a;">;; this creates a local variable in the method activation
</span>  <span style="color: #b0c4de;">foo</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
)

<span style="color: #0000cd;">Foo</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
<span style="color: #606060;">Foo</span> <span style="color: #449900;">do</span>(
  <span style="color: #a52a2a;">;; this creates the cell foo inside of Foo
</span>  <span style="color: #b0c4de;">foo</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
)</pre>

                  <p>Here you can see a method defined called x. This method will just create a new local cell, which means calling the method will not make any difference on its receiver at all. The call to "do" in contrast will immediately execute the code inside it, and this code will create the cell "foo" inside of "Foo".</p>

                  <p>The second exception to the general rule is when executing inside of a lexical context. A lexical context is basically established inside of a block, but can also be created transparently when sending code to a method. A lexical block will try to not create new cells. When you assign a cell without a specific place to assign it, a lexical block will first see if there is any cell with that name further out, and if so it will make the assignment there instead. Only when no such cell exists, a new cell will be created in the lexical context. This code shows this in action:</p>
                  <pre class="code">
<span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
<span style="color: #6495ed;">fn</span>(<span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">43</span><span style="color: #006666;">.</span> <span style="color: #b0c4de;">y</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>) <span style="color: #449900;">call</span>
x <span style="color: #a52a2a;">;; =&gt; 42
</span>y <span style="color: #a52a2a;">;; =&gt; Condition Error NoSuchCell</span></pre>
                  
                  <p>The "fn" message creates a new lexical block. The chapter on <a href="#code">code</a> will talk more about this. But as you can see, this block assigns 43 to the cell "x", and 42 to the cell "y". But since the cell "y" doesn't exist, it will only be created inside the lexical context, while "x" exists outside, and will be assigned a new value instead. The basic ideas is that code like this should behave like you expect it to behave.</p>

                  <p>The canonical form of assignment is a bit different from the way you usually code Ioke. The section on the syntax of assignments talked a bit about this. Specifically, something like "foo = 42" will get translated into "=(foo, 42)". That also means that assignment is just regular method call, that can be overridden or removed just like any other method. And that is exactly how both lexical context, and local method context make it possible to have different logic here. This is true for all assignment operators.</p>
                  
                  <p>All assignment operators take as their first argument the place to assign to. This place will be unevaluated. Only the second argument to an assignment will be evaluated. In most cases, a place is the same thing as a cell name, but it doesn't have to be. Let's look at the case of assigning a cell with a strange name. Say we want to assign the cell with the no name. We can do it like this:</p>
                  <pre class="code">
<span style="color: #449900;">cell</span>(<span style="color: #0050a0;">""</span>) <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span></pre>

                  <p>What happens here is a bit subtle. Since the left hand side of the assignment takes arguments, the "=" method figures out that the assignment is not to a simple cell name, but to a place. The parsing step will change "cell("") = 42" into "=(cell(""), 42)". Notice here that the argument comes along into the specification of the place. When this happens, the assignment operatoer will not try to create or assign a cell - instead it will in this case call the method cell=. So "cell("") = 42" will ultimately end up being the same as "cell=("", 42)". This way of transforming the name work the same for all cases, so you can have as many arguments as you want to the place on the left hand side. The equals sign will be added to the method name, and a message will be sent to that instead.</p>
                  <p>This makes assignment of places highly flexible, and the only thing you need to do is to implement methods with the right names. This feature is used extensively in Lists and Dicts to make it easy to assign to specifix indexes. So, say we have a list called x. Then this code: "x[13] = 42" will be transformed into "x =([](13), 42)" which will in turn be transformed into "x []=(13, 42)". Ioke lists also has an at= method, so you can do "x at(13) = 42" which will call at=, of course.</p>

                  <p>The second transformation that might happen is that if you try to assign a cell that have an assigner, you will call that assigner instead of actually assigning a cell. So, for example, if you do "foo documentation = 42", this will not actually create or assign the cell "documentation". Instead it will find that Base has a cell called "documentation=", and instead send that message. So the prior code would actually be equivalent to "foo documentation=(42)".</p>

                  <p>All of these assignment processes together make it really easy to take control over assignment, while still making it very obvious and natural in most cases.</p>
                </div>

                <div class="chapter">
                  <h2><a name="controlFlow">Control flow</a></h2>
                  <p>Ioke has some standard control flower operators, like most other languages. In Ioke, all of these are regular method calls, though, and they can usually be implemented in terms of Ioke. This chapter will chiefly talk about comparisons, conditionals and iteration constructs.</p>

                  <div class="section">
                    <h3><a name="comparison">Comparison</a></h3>
                    <p>There are several comparison operators in Ioke, but the most important is called the spaceship operator. This operator is &lt;=&gt;. It takes one argument and returns -1, 0 or 1 depending on the ordering of the receiver and the argument. If the two objects can't be compared, it returns nil. If you implement this operator and mixin Mixins Comparing, you get the operators ==, !=, &lt;, &lt;=, &gt; and &gt;= implemented in terms of the spaceship operator. There are two other common operators in Ioke. The first ~=, which can also be called the match operator. It's only implemented for Regexp right now. The === operator also exists, but isn't implemented for most objects. This operator doesn't do much right now, but is planned to be the basis of a Ruby-like case-statement further down the line. The contract of comparison operators is that they should return a true value (not necessarily the true), if the comparison is true, and otherwise return either false or nil.</p>

                    <p>The contract for === should be matching or not matching. It is among other things used in Ranges to see if something is included in that range or not.</p>

                    <pre class="code">
iik&gt; 1 + 2 &lt; 4
+&gt; true

iik&gt; 3 + 2 &lt; 4
+&gt; false

iik&gt; "foo" &lt;=&gt; "fop"
+&gt; -1</pre>
                  </div>

                  <div class="section">
                    <h3><a name="conditionals">Conditionals</a></h3>
                    <p>Ioke has two different ways of doing conditionals. The first one is the default, and is also the traditional conditional from other languages. The second version looks more like Smalltalk conditionals.</p>

                    <p>As with everything else, these conditionals are all methods, and can be overridden and changed if need be. They can also be polymorphic.</p>

                    <p>The default conditionals are called "if" and "unless". They both take an initial evaluated argument that is used to check which branch should be taken. The "if" method will execute it's second argument if the first argument is true, and the third argument if the first argument is false. The "unless" method does the inverse -- executing the second argument if the first argument is false, and the third argument if the first argument is true. One or both of the branches can be left out from the statement. If no else-part is around and the conditional part evaluates to a false value, that false value will be returned.</p>

                    <p>A few examples are in order:</p>
                    <pre class="code">
<span style="color: #6495ed;">if</span>(<span style="color: #0050a0;">42</span> &lt; <span style="color: #0050a0;">43</span><span style="color: #006666;">,</span>
  <span style="color: #0050a0;">"wow, math comparison works"</span> <span style="color: #449900;">println</span><span style="color: #006666;">,</span>
  <span style="color: #0050a0;">"we have some serious trouble"</span> <span style="color: #449900;">println</span>)

<span style="color: #6495ed;">if</span>(<span style="color: #0050a0;">42</span> &lt; <span style="color: #0050a0;">43</span><span style="color: #006666;">,</span>
  <span style="color: #0050a0;">"wow, math comparison works"</span><span style="color: #006666;">,</span>
  <span style="color: #0050a0;">"we have some serious trouble"</span>) <span style="color: #449900;">println</span>

<span style="color: #6495ed;">unless</span>(<span style="color: #0050a0;">42</span> &lt; <span style="color: #0050a0;">43</span><span style="color: #006666;">,</span>
  <span style="color: #0050a0;">"convoluted math"</span> <span style="color: #449900;">println</span>)</pre>

                    <p>It is good style to not use "unless" with an else branch. It generally tends to not be so readable that way. Remember that "if" and "unless" return their values, which means they are expressions like everything else. The middle example show that you can just call println on the result of the if-call, instead of doing it twice inside. This is also good style. Assigning the result of an if-call is likewise not a problem.</p>

                    <p>In some languages you see a pattern such as "if(foo = someExpensiveMethodCall(), foo println)", where a variable is assigned in the condition evaluation so the value doesn't have to be evaluated twice. This works in Ioke too, but there is a more idiomatic way of doing it. Both "if" and "unless" establish a lexical context, where a variable called "it" is available. This variable will be bound to the result of the conditional. So the above idiom could instead be written "if(someExpensiveMethodCall(), it println)". This is the preferred way of handling regular expression matching.</p>

                    <p>The Smalltalk inspired way of doing conditionals rest on the methods called ifTrue and ifFalse. Both of these methods are only defined on true and false, which means they are not as general as the if and unless statements. They can also be chained together, so you can write:</p>

                    <pre class="code">
(<span style="color: #0050a0;">42</span> &lt; <span style="color: #0050a0;">43</span>) ifTrue(<span style="color: #0050a0;">"wowsie!"</span> <span style="color: #449900;">println</span>) ifFalse(<span style="color: #0050a0;">"oh noes"</span> <span style="color: #449900;">println</span>)</pre>

                    <p>As should be obvious from these examples, these conditionals can not return any value. They must only rely on side effects to achieve anything.</p>

                    <p>Ioke also supports the expected short circuiting boolean evaluators. They are implemented as regular methods and are available on all objects. All of the expected combinators are available, including "and", "&amp;&amp;", "or", "||", "xor", "nor" and "nand".</p>
                  </div>

                  <div class="section">
                    <h3><a name="iteration">Iteration</a></h3>
                    <p>Ioke supports most of the expected control flow operations for iteration. The one thing that is missing is the for-loop. Since the for-loop encourages low level stepping, and canbe replaced by other kinds of operations, I don't see any reason in having it in Ioke. In fact, the for-statement in Ruby is generally considered bad form too. And if someone really wants a for-loop it's really easy to implement. For now I'm reserving the name if I would like to add comprehensions at some point.</p>

                    <h4>loop</h4>
                    <p>For creating infinte loops, the "loop"-method is the thing. It will just take a piece of code and execute it over and over again until some non-local flow control rips the execution up. Using it is as simple as calling it:</p>

                    <pre class="code">
<span style="color: #449900;">loop</span>(<span style="color: #0050a0;">"hello"</span> <span style="color: #449900;">println</span>)

<span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">0</span>
<span style="color: #449900;">loop</span>(
  <span style="color: #6495ed;">if</span>(x &gt; <span style="color: #0050a0;">10</span><span style="color: #006666;">,</span> <span style="color: #6495ed;">break</span>)
  x<span style="color: #00bfff;">++</span>
)</pre>

                    <p>The first example will loop forever, printing hello over and over again. The second example will increment a variable until it's larger then 10, and then it will break out of the loop.</p>

                    <h4>while</h4>
                    <p>The Ioke while loop works exactly like while-loops in other languages. It takes one argument that is a condition to reevaluate on each iteration, and another argument that is the code to evaluate each iteration. The result of the while-loop is the result of the last executed expression in the body.</p>

                    <pre class="code">
<span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">0</span>
<span style="color: #449900;">while</span>(x &lt; <span style="color: #0050a0;">10</span><span style="color: #006666;">,</span>
  x <span style="color: #449900;">println</span>
  x<span style="color: #00bfff;">++</span>
)</pre>

                    <h4>until</h4>
                    <p>The until-loop works the same as the while-loop, except it expects it's condition argument to evaluate to false. It will stop iterating when the conditional is true for the first time.</p>
                    
                    <pre class="code">
<span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">0</span>
<span style="color: #449900;">until</span>(x <span style="color: #00bfff;">==</span> <span style="color: #0050a0;">10</span><span style="color: #006666;">,</span>
  x <span style="color: #449900;">println</span>
  x<span style="color: #00bfff;">++</span>
)</pre>

                    <h4>times</h4>
                    <p>A very common need is to iterate something a certain number of times. The Number Integer kind defines a method called "times" that does exactly this. It's got two forms - one with one argument and one with two arguments. With one argument, it will just run the argument code the specified number of times, and with two arguments the first argument should be the name of a cell to assign the current iteration value to and the second is the code to execute.</p>

                    <pre class="code">
<span style="color: #0050a0;">3</span> times(<span style="color: #0050a0;">"hello"</span> <span style="color: #449900;">println</span>)

<span style="color: #0050a0;">4</span> times(n<span style="color: #006666;">,</span>
  <span style="color: #0050a0;">"#{n}: wow"</span> <span style="color: #449900;">println</span>)</pre>
                    
                    <p>The first example will print hello three times, while the second example will count up from 0 to 3, printing the number followed by "wow".</p>

                    <h4>each</h4>
                    <p>For most iteration needs, you want to traverse a collection in some way. The standard way of doing this is with the "each"-method. It's defined on all central collection classes and is also the basis of the contract for Mixins Enumerable. The contract for each has three different forms, and all should be implemented if you decide to implement the each method.</p>

                    <p>The each method should -- as the name implies -- do something for each entry in the collection it belongs to. So calling each on a set would do something with each entry, etc. Exactly what that is depends on how many arguments are given to "each".</p>
                    
                    <p>If one argument is given, it should be a message chain. This message chain will be applied to each element.</p>
                    <pre class="code">
[<span style="color: #7777d4;">:one</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">:two</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">:three</span>] each(<span style="color: #449900;">inspect</span> <span style="color: #449900;">println</span>)

<span style="color: #a52a2a;">;; the above would execute:
</span><span style="color: #7777d4;">:one</span> <span style="color: #449900;">inspect</span> <span style="color: #449900;">println</span>
<span style="color: #7777d4;">:two</span> <span style="color: #449900;">inspect</span> <span style="color: #449900;">println</span>
<span style="color: #7777d4;">:three</span> <span style="color: #449900;">inspect</span> <span style="color: #449900;">println</span></pre>

                    <p>Another way of saying it is that the message chain will be executed using each element of the collection as receiver, in turn. The return value will be thrown away in this case, so to achieve anything, the code need to mutate data somewhere.</p>

                    <p>The second -- and most common -- form, takes two arguments. The first argument should be the name of a cell to assign each element to, and the second argument should be the code to execute. Under the covers, this form will establish a new lexical context for the code to run in. As with the first version, each return value will be trown away.</p>

                    <pre class="code">
[<span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">4</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">6</span>] each(x<span style="color: #006666;">,</span> (x<span style="color: #00bfff;">*</span>x) <span style="color: #449900;">println</span>)</pre>

                    <p>Here, the name "x" will be used as the name of each element of the list in turn, while executing the code.</p>

                    <p>The final form of each takes three arguments, where the first is the name of a cell to assign the current index, and the other two arguments are the same as the above.</p>
                    <pre class="code">
[<span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">4</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">6</span>] each(i<span style="color: #006666;">,</span> x<span style="color: #006666;">,</span> <span style="color: #0050a0;">"#{i}: #{(x*x)}"</span> <span style="color: #449900;">println</span>)</pre>

                    <p>The above code would print:</p>
                    <pre class="code">
0: 4
1: 16
2: 36</pre>

                    <h4>break, continue</h4>
                    <p>When executing loops it is sometimes important to be able to interrupt execution prematurely. In this cases the break and continue methods allow this for "loop", "while" and "until". Both break and continue work lexically, so if you send code to another method that uses these methods, they will generally jump out of a lexically visible loop, just like expected.</p>

                    <p>The break method takes an optional value to return. If no value is provided it will default to nil. When breaking out of a loop, that loop will return the value given to break. The continue method will not break out of the execution, but will instead jump to the beginning and reevaluate the condition once again.</p>

                    <pre class="code">
<span style="color: #449900;">while</span>(<span style="color: #6495ed;">true</span><span style="color: #006666;">,</span>
  <span style="color: #6495ed;">break</span>(<span style="color: #0050a0;">42</span>))</pre>

                    <p>This code will immediately return 42 from the while-loop, even though it should have iterated forever.</p>

                    <pre class="code">
<span style="color: #b0c4de;">i</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">0</span>
<span style="color: #449900;">while</span>(i &lt; <span style="color: #0050a0;">10</span><span style="color: #006666;">,</span>
  i <span style="color: #449900;">println</span>
  <span style="color: #6495ed;">if</span>(i <span style="color: #00bfff;">==</span> <span style="color: #0050a0;">5</span><span style="color: #006666;">,</span>
    <span style="color: #b0c4de;">i</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">7</span>
    continue)
  i<span style="color: #00bfff;">++</span>
)</pre>

                    <p>This code uses continue to jump over a specific number, so it will only print 0 to 5, and 7 to 9.</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="code">Code</a></h2>
                  <p>Many of the things you do in Ioke will directly manipulate code. Since the messages that make up code is really easy to get hold of, this manipulation comes easy too. Ioke takes the Lisp philosophy of "code is data" to heart. The basic unit of a piece of code is a Message. A Message has a name, a next and prev pointer, and any number of arguments. When you manipulate a message, the argument list will contain messages too - and if the next or prev pointers are not nil, they will point to other messages. It serves well to remember that except for the message itself, all code will be evaluated in the context of a receiver and a ground. The ground is necessary because arguments to be evaluated need to be run in some specific context, even though the current receiver is not the same as the ground.</p>

                  <p>The current types of code can be divided into three different categories. These are methods, macros and blocks. Native methods are all of the kind JavaMethod, but can have any kind of semantics - including semantics that look like this macros. Most native methods do have the same semantics as regular methods, though.</p>

                  <div class="section">
                    <h3><a name="methods">Methods</a></h3>
                    <p>A method in Ioke is executable code that is activatable. A method can take arguments of several different types. The arguments to a method will always be evaluated before the code in the method starts to execute. An Ioke method is defined using the "method" method. All Ioke methods have the kind DefaultMethod. This leaves the room open to define other kinds of methods, if need be. DefaultMethod's could be implemented using macros, but at this point they aren't. A DefaultMethod can have a name - and will get a name the first time it is assigned to a cell.</p>

                    <p>It is really easy to define and use a simple method. The easiest case is to define a method that is empty. This method will just return nil:</p>
                    <pre class="code">
<span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>()
m <span style="color: #a52a2a;">;; call the method
</span></pre>

                    <p>Since methods are activatable, when you name a cell that contains a method, that method will be invoked. To stop that behavior, use the "cell" method.</p>

                    <p>The definition of a method can take several different pieces. These are a documentation string, definitions of positional required arguments, definitions of positional optional arguments, definitions of keyword arguments, definition of a rest argument, definition of a keyword rest argument and the actual code of the method.</p>

                    <p>Let's take these one by one. First, if the the first element of a call to "method" is a literal text, and there is a at least one more argument in the definition, then that text will be the documentation text for the method:</p>

                    <pre class="code">
<span style="color: #a52a2a;">;; a method that returns "foo"
</span><span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(<span style="color: #0050a0;">"foo"</span>) 

<span style="color: #a52a2a;">;; a method that returns nil, but
;; has the documentation text "foo"
</span><span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(<span style="color: #0050a0;">"foo"</span><span style="color: #006666;">,</span> <span style="color: #6495ed;">nil</span>)</pre>

                    <p>A method can take any number of required positional arguments. These will be checked when a method is called, and if not enough -- or too many -- arguments are provided, an error will be signalled.</p>
                    <pre class="code">
<span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(x<span style="color: #006666;">,</span> x <span style="color: #449900;">println</span>)
<span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(x<span style="color: #006666;">,</span> y<span style="color: #006666;">,</span> z<span style="color: #006666;">,</span>
  x <span style="color: #00bfff;">*</span> y <span style="color: #00bfff;">+</span> z)</pre>

                    <p>The first method takes one argument and prints that argument. The second method takes three arguments and return the product of the two first added to the third.</p>

                    <p>A method can also have optional positional arguments. In that case the optional arguments must follow the required arguments. Optional arguments need to have a default value -- in fact, that is how you distinguish them from required arguments. The arity of method calls will still be checked, but using minimum and maximum values instead. The default value for an argument should be code that can be executed in the context of the running method, so a default value can refer to earlier positional arguments. A default value can also do quite complex things, if need be, although it's really not recommended.</p>

                    <pre class="code">
<span style="color: #a52a2a;">;; takes zero or one arguments
</span><span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(x <span style="color: #0050a0;">42</span><span style="color: #006666;">,</span> x <span style="color: #449900;">println</span>)

<span style="color: #a52a2a;">;; takes one to three arguments
</span><span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(x<span style="color: #006666;">,</span> y <span style="color: #0050a0;">42</span><span style="color: #006666;">,</span> z <span style="color: #0050a0;">25</span><span style="color: #006666;">,</span> 
  x<span style="color: #00bfff;">*</span>y <span style="color: #00bfff;">+</span> z)</pre>

                    <p>The syntax for optional arguments is to just write a space after the name of the argument, and then write the code to generate the default value after it.</p>

                    <p>A method can also have keyword arguments. Keyword arguments are checked, just like regular arguments, and you can't generally give keyword arguments to a method not expecting it. Nor can you give unexpected keyword arguments to a method that takes other keywords. Keyword arguments can never be required. They can have default values, which will default to nil if not provided. They can be defined anywhere among the arguments -- the only reason to reorder them is that default values of other optional arguments can use prior defined keyword arguments.</p>

                    <p>A keyword argument is defined just like a regular argument, except that it ends in a colon.</p>

                    <pre class="code">
<span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(<span style="color: #7777d4;">foo:</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">bar:</span> <span style="color: #0050a0;">42</span><span style="color: #006666;">,</span>
  foo <span style="color: #449900;">println</span>
  bar <span style="color: #449900;">println</span>
)</pre>

                    <p>Just as with regular optional arguments, you supply the default value of the keyword argument after a space. The cells for the keyword arguments will be the same as their names, without the ending colon. The above code would print nil and 42 if no arguments were specified. It's important to remember that keyword arguments and positional arguments do not interact -- except for when calculating default values. When assigning values it's always possible to see what is positional and what is a keyword argument.</p>

                    <p>Ioke methods can collect positional arguments into a list. This allow methods to take variable number of arguments. The rule is that all other positional arguments are first calculated, and the remaining positional arguments will be added to the rest argument. If no positional arguments are available, the rest argument will be empty. A rest argument is defined by preceding it with a plus sign in the argument definition. For clarity a rest argument should be defined last in the list, although it doesn't exactly matter anyway.</p>

                    <pre class="code">
<span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(<span style="color: #00bfff;">+</span>rest<span style="color: #006666;">,</span>
  rest <span style="color: #449900;">println</span>)

<span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(x<span style="color: #006666;">,</span> y <span style="color: #0050a0;">42</span><span style="color: #006666;">,</span> <span style="color: #00bfff;">+</span>rest<span style="color: #006666;">,</span>
  rest <span style="color: #449900;">println</span>)</pre>

                    <p>The above code defines one method that only takes one rest argument. That means the method can take any number of arguments and all of them will be collected into a list. The second method takes one required argument, one optional argument and any number of extra arguments. So if 4 arguments are given, the rest argument will contain two.</p>

                    <p>The final type of argument is keyword rest arguments. Just like positional rest arguments, a keyword rest argument can collect all keywords given to a method, no matter what. If a keyword rest argument is used, no conditions will be signalled if an unknown keyword is given to a method. If other keywords are defined, these keywords will not show up in the keyword rest argument. The keyword rest argument is defined by preceding the name with a +: sigil, and the keyword rest argument will be a Dict instead of a list. The keys will be symbols but without the ending colon.</p>

                    <pre class="code">
<span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(<span style="color: #00bfff;">+</span><span style="color: #7777d4;">:krest</span><span style="color: #006666;">,</span>
  krest <span style="color: #449900;">println</span>)

<span style="color: #b0c4de;">m</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(x<span style="color: #006666;">,</span> <span style="color: #7777d4;">y:</span><span style="color: #006666;">,</span> <span style="color: #00bfff;">+</span>rest<span style="color: #006666;">,</span> <span style="color: #00bfff;">+</span><span style="color: #7777d4;">:krest</span><span style="color: #006666;">,</span>
  [x<span style="color: #006666;">,</span> y<span style="color: #006666;">,</span> rest<span style="color: #006666;">,</span> krest] <span style="color: #449900;">println</span>)</pre>

                    <p>The above code first creates a method that can take any number of keyword arguments but nothing else. The second method takes one required positional argument, one keyword argument, rest arguments and keyword rest arguments, and returns a new list containing all the arguments given to it.</p>

                    <p>The final argument to the method method should always be the code to execute. This code will be executed in the context of a receiver, that is the object the method is activated on. A method execution also happens in the context of the method activation context, where local variables are stored. This activation context contain some predefined variables that can be used. These are "self", "@", "currentMessage" and "surroundingContext". Both "self" and "@" refer to the receiver of the method call. "currentMessage" returns the message that initiated the activation of the method, and "surroundingContext" returns the object that represents the context where this method was called from. Both "self" and "@" can be used to specify that something should be assigned to the receiver, for example.</p>
                    <pre class="code">
<span style="color: #b0c4de;">createNewCell</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(
  <span style="color: #006666;">@</span><span style="color: #b0c4de;">foo</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
)</pre>
                    
                    <p>The method create above will create assign the value 42 to the cell "foo" on the object the method was called on.</p>

                    <p>When calling a method, you specify positional arguments separated with commas. You can provide keyword arguments in any order, in any place inside the braces:</p>
                    <pre class="code">
<span style="color: #a52a2a;">;; the method foo takes any kind of argument
</span>foo
foo()
foo(<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span>)
foo(<span style="color: #7777d4;">blarg:</span> <span style="color: #0050a0;">42</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">4</span>)
foo(<span style="color: #7777d4;">quux:</span> <span style="color: #0050a0;">42</span><span style="color: #00bfff;">*</span><span style="color: #0050a0;">2</span>)</pre>

                    <p>To give a keyword argument, you just write it exactly like you define keyword arugments - a name followed by a colon.</p>

                    <p>Sometimes it can be useful to be able to take a list of values and give them as positional arguments. The same can be useful to do with a dict of names. You can do that using splatting. This is done by preceding a list or a dict with an asterisk. This will result in the method getting the values inside of it as if the arguments were given directly. You can splat several things to the same invocation.</p>

                    <pre class="code">
<span style="color: #b0c4de;">dc</span> <span style="color: #00bfff;">=</span> {<span style="color: #7777d4;">foo:</span> <span style="color: #0050a0;">42</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">bar:</span> <span style="color: #0050a0;">13</span>}
<span style="color: #b0c4de;">ls</span> <span style="color: #00bfff;">=</span> [<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">4</span>]
<span style="color: #b0c4de;">ls2</span> <span style="color: #00bfff;">=</span> [<span style="color: #0050a0;">42</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">43</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">44</span>]

foo(<span style="color: #00bfff;">*</span>dc)
<span style="color: #a52a2a;">;; the same as:
</span>foo(<span style="color: #7777d4;">foo:</span> <span style="color: #0050a0;">42</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">bar:</span> <span style="color: #0050a0;">13</span>)

foo(<span style="color: #00bfff;">*</span>ls)
<span style="color: #a52a2a;">;; the same as:
</span>foo(<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">4</span>)

foo(<span style="color: #00bfff;">*</span>ls2<span style="color: #006666;">,</span> <span style="color: #0050a0;">111</span><span style="color: #006666;">,</span> <span style="color: #00bfff;">*</span>dc<span style="color: #006666;">,</span> <span style="color: #00bfff;">*</span>ls)
<span style="color: #a52a2a;">;; the same as:
</span>foo(<span style="color: #0050a0;">42</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">43</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">44</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">111</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">foo:</span> <span style="color: #0050a0;">42</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">bar:</span> <span style="color: #0050a0;">13</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">4</span>)</pre>

                    <p>If you try to splat something that can't be splatted, a condition will be signalled.</p>
                  </div>

                  <div class="section">
                    <h3><a name="macros">Macros</a></h3>
                    <p>The main difference between a macro and a method in Ioke is that the arguments to a macro is not evaluated before they are sent to the macro. That means you have to use macros to send raw message chains in an invocation. In most languages, this kind of feature is generally called call-by-name. When a macro gets called, it will get access to a cell called "call" which is a mimic of the kind Call. This gives access to information about the call and makes it possible to evaluate the code sent as arguments, check how many arguments are supplied, and so on.</p>

                    <p>A macro is created using the "macro" cell on DefaultBehavior. This will return a mimic of DefaultMacro. Since a macro can't define arguments, it's a bit easier to describe than mathods, but the things that can be done with macro is also a bit more interesting than what can be achieved by methods. One important thing to keep in mind is that most macros can not receive splatted arguments. In most cases keyword arguments aren't available either - but they could be faked if needed. Macros should generally be used to implement control structures and things that need to manipulate code in different ways.</p>

                    <p>Just like a methods, a macro gets evaluated on a specific receiver. It also gets the same kind of method activation context, but the contents of it is a bit different. Specifically, the context for a macro contains cells named "self", "@", "currentMessage", "surroundingContext" and "call". It's the "call" cell that is most important. It is a mimic of Call, and Call defines several important methods for manipulating the call environment. These are:</p>
                    <dl>
                      <dt>arguments</dt>
                      <dd>This method returns a list containing the unevaluated arguments given to this message. Any kind of manipulation can be done with these arguments.</dd>

                      <dt>ground</dt>
                      <dd>Returns the ground in which the call was initiated. This is necessary to evaluate arguments in their own environment.</dd>

                      <dt>message</dt>
                      <dd>The currently executing message. This is the same as the "currentMessage" cell in the macro activation context.</dd>

                      <dt>evaluatedArguments</dt>
                      <dd>Returns a list containing all arguments, evaluated according to the regular rules (but not handling splatting or keywords).</dd>

                      <dt>resendToMethod</dt>
                      <dd>Allows a specific message to be resent to another method, without manually copying lots of information.</dd>
                    </dl>

                    <p>These methods are a bit hard to understand, so I'll take some examples from the implementation of Ioke, and show how macros are used here.</p>

                    <pre class="code">
<span style="color: #8b0000;">Mixins</span> <span style="color: #606060;">Enumerable</span> <span style="color: #b0c4de;">map</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">macro</span>(
  <span style="color: #0050a0;">"takes one or two arguments. if one argument is given,
it will be evaluated as a message chain on each element
in the enumerable, and then the result will be collected
in a new List. if two arguments are given, the first one
should be an unevaluated argument name, which will be
bound inside the scope of executing the second piece of
code. it's important to notice that the one argument
form will establish no context, while the two argument form
establishes a new lexical closure."</span><span style="color: #006666;">,</span>
  
  <span style="color: #b0c4de;">len</span> <span style="color: #00bfff;">=</span> <span style="color: #449900;">call</span> arguments length
  <span style="color: #b0c4de;">result</span> <span style="color: #00bfff;">=</span> <span style="color: #449900;">list</span>()
  <span style="color: #6495ed;">if</span>(len <span style="color: #00bfff;">==</span> <span style="color: #0050a0;">1</span><span style="color: #006666;">,</span>
    <span style="color: #b0c4de;">code</span> <span style="color: #00bfff;">=</span> <span style="color: #449900;">call</span> arguments first
    <span style="color: #6495ed;">self</span> each(n<span style="color: #006666;">,</span> result &lt;&lt; code evaluateOn(<span style="color: #449900;">call</span> ground<span style="color: #006666;">,</span> <span style="color: #449900;">cell</span>(<span style="color: #7777d4;">:n</span>)))<span style="color: #006666;">,</span>

    <span style="color: #b0c4de;">code</span> <span style="color: #00bfff;">=</span> <span style="color: #606060;">LexicalBlock</span> createFrom(<span style="color: #449900;">call</span> arguments<span style="color: #006666;">,</span> <span style="color: #449900;">call</span> ground)
    <span style="color: #6495ed;">self</span> each(n<span style="color: #006666;">,</span> result &lt;&lt; code <span style="color: #449900;">call</span>(<span style="color: #449900;">cell</span>(<span style="color: #7777d4;">:n</span>))))
  result)</pre>

                    <p>The code above implements map, one of the methods from Enumerable. The map method allows one collection to be mapped in a predefined way into something else. It can take either one or two arguments. If one argument is given, that is a message chain to apply, and then collect the results. If two arguments are given, the first is the argument name to use, and the second is the code to execute for each entry.</p>

                    <p>The first step is to figure out how many arguments have been given. This is done by checking the length of the "call arguments" cell. If we have a length of one, we know that the first argument is a piece of code to apply, so we assign that argument to a cell called "code". Now, "code" will be a mimic of Message, and Message has a method called "evaluateOn", that can be used to fully evaluate a message chain. And that's exacty what we do for each element in the collection we are in. The result of evaluateOn is added to the result list. We use "call ground" to get the correct ground for the code to be evaluated in.</p>

                    <p>If we get two arguments, it's possible to take a shortcut and generate a lexical block from those arguments, and then use that. So we call "LexicalBlock createFrom" and send in the arguments and the ground, and then call that piece of code once for each element in the collection.</p>

                    <p>It is a bit tricky to figure out how macros work. I recommend looking at the implementations of some of the core Ioke methods/macros, since these use much of the functionality.</p>
                  </div>

                  <div class="section">
                    <h3><a name="blocks">Blocks</a></h3>
                    <p>A lexical block allows the execution of a piece of code in the lexical context of other code, instead of in a dynamic object scope. A lexical block does not have a receiver. Instead it just established a new lexical context, and executes the code in that. Exactly what effect that has on assignments have been described earlier.</p>

                    <p>A lexical block can be created using either the "fn" or the "fnx" methods of DefaultBehavior. The main difference is that a block created with "fnx" will be activatable, will something created with "fn" will not. Lexical blocks handle arguments exactly the same way as methods, so a lexical block can take optional arguments, keyword arguments, rest arguments and so on. Both "fn" and "fnx" also takes an optional documentation text.</p>

                    <p>A block can be invoked by calling the "call" method. A block can also be activated just like methods, if it's activatable. The default is to use "fn" to create inactive blocks, though, since blocks are generally used to pass around pieces of code.</p>

                    <pre class="code">
<span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">fn</span>(z<span style="color: #006666;">,</span> z <span style="color: #449900;">println</span>)
<span style="color: #b0c4de;">y</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">fnx</span>(z<span style="color: #006666;">,</span> z <span style="color: #449900;">println</span>)

x <span style="color: #449900;">call</span>(<span style="color: #0050a0;">42</span>)
y(<span style="color: #0050a0;">42</span>)</pre>

                    <p>A lexical block is a regular kind of object that can be assigned to any cell, just like other objects. Lexical blocks mimic LexicalBlock, and blocks doesn't have names. In contrast to methods and macros, no extra cells will be added to the activation context for a lexical block.</p>
                  </div>

                  <div class="section">
                    <h3><a name="messageChains">Message chains</a></h3>
                    <p>In many cases a macro will take code that is not wrapped up inside of a method, macro or block. These pieces of code is called message chains, since their representation will be to a raw Message mimic. The chains are quite flexible, since they can be taken apart, modified and put together again. They can also be unevaluated and used as data definitions of some kind. That's how the argument handling to methods are implemented, for example. Since the call to "method" can be seen as a regular call to a macro, the argument descriptions are actually just unevaluated message chains that are picked apart to tease out the argument names. The same technique is applicable in any macro usage.</p>

                    <p>The term message chain fragment is also used to specifically mean a message chain that is meant to be put together with something and evaluated. Picture a daisy chain that gets added at the end of another chain and then executed. That's what happens if you execute something like "[1, 2, 3] map(*2)". In this case the call to "*" with the argument 2 will be a message chain fragment that will be put together with a new receiver before execution.</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="introspection">Introspection and reflection</a></h2>
                  <p>Ioke supports quite fancy introspection and reflection capabilities. In Ioke, reflection includes the ability to change data dynamically, as well as introspect on it. Since the message based structure of a program is available at runtime, most things can be changed dynamically. The internal structure of a program is also very easy to inspect.</p>

                  <p>All objects in Ioke have some core methods that are used to look at them. Some come from Base, and some come from DefaultBehavior. The rest of the reflection and metaprogramming capabilities belong to the Message kind.</p>
                  
                  <h4>kind</h4>
                  <p>Should be a text that gives the full name of the kind this object is closest mimic to. Except for nil, true and false, this will return a text that starts with a capital letter.</p>
                  <pre class="code">
<span style="color: #0000cd;">Foo</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
<span style="color: #606060;">Foo</span> <span style="color: #6495ed;">mimic</span> kind <span style="color: #449900;">println</span>

<span style="color: #606060;">Foo</span> <span style="color: #0000cd;">Bar</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
<span style="color: #606060;">Foo</span> <span style="color: #606060;">Bar</span> <span style="color: #6495ed;">mimic</span> kind <span style="color: #449900;">println</span></pre>

                  <p>This code will first print "Foo", and then print "Foo Bar", since an object assigned to a cell with a capital initial letter will get a new kind value.</p>

                  <h4>kind?</h4>
                  <p>Takes one text argument and returns true if the object has that kind anywhere in it's mimic chain.</p>
                  <pre class="code">
<span style="color: #0000cd;">Foo</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
<span style="color: #0000cd;">foo</span> <span style="color: #00bfff;">=</span> <span style="color: #606060;">Foo</span> <span style="color: #6495ed;">mimic</span>
foo kind?(<span style="color: #0050a0;">"foo"</span>) <span style="color: #a52a2a;">;; false
</span>foo kind?(<span style="color: #0050a0;">"Foo"</span>) <span style="color: #a52a2a;">;; true
</span>foo kind?(<span style="color: #0050a0;">"Text"</span>) <span style="color: #a52a2a;">;; false
</span>foo kind?(<span style="color: #0050a0;">"Origin"</span>) <span style="color: #a52a2a;">;; true
</span>foo kind?(<span style="color: #0050a0;">"Ground"</span>) <span style="color: #a52a2a;">;; true
</span>foo kind?(<span style="color: #0050a0;">"DefaultBehavior"</span>) <span style="color: #a52a2a;">;; true
</span>foo kind?(<span style="color: #0050a0;">"Base"</span>) <span style="color: #a52a2a;">;; true</span></pre>

                  <p>As you can see in this example, "kind?" can return true for several different texts.</p>

                  <h4>notice</h4>
                  <p>When looking at objects, there are two ways to get information about them, notice and inspect. If you want a brief description of an object where it's more important that it doesn't take up much space, notice should be used. If an exhaustive description is needed, inspect should be used instead. For some objects these both return the same thing, but for Origin mimics, the difference is large.</p>
                  <pre class="code">
<span style="color: #0000cd;">Foo</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
<span style="color: #606060;">Foo</span> <span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">"blarg"</span>
<span style="color: #606060;">Foo</span> <span style="color: #b0c4de;">y</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
<span style="color: #606060;">Foo</span> notice <span style="color: #a52a2a;">;; Foo_0x7CBDE6
</span></pre>

                  <p>The default notice for Origin mimics will combine the kind and the unique hex id for the object, and create a text of that. The "notice" method should be overridden to provide better information in most cases.</p>
                  
                  <h4>inspect</h4>
                  <p>In contrast to notice, inspect is used to get exhaustive information. If a composite object is asked for its inspect, a quite large dump of information will often be shown. For a new object the output will be smaller, but usually still larger than the notice for it.</p>

                  <pre class="code">
<span style="color: #0000cd;">Foo</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
<span style="color: #606060;">Foo</span> <span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">"blarg"</span>
<span style="color: #606060;">Foo</span> <span style="color: #b0c4de;">y</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
<span style="color: #606060;">Foo</span> <span style="color: #449900;">inspect</span> <span style="color: #449900;">println</span></pre>

                  <p>This will print:</p>
                  <pre class="code">
 Foo_0x7CBDE6:
  kind                         = "Foo"
  x                            = "blarg"
  y                            = 42</pre>

                  <p>If another representation makes more sense for inspection, "inspect" should definitely be overridden by custom objects.</p>

                  <h4>uniqueHexId</h4>
                  <p>This method is used to return a text that contains a unique hex identity for an object. This text is guaranteed to be unique within a virtual machine for any object, and is the mechanism that "inspect" and "notice" uses.</p>

                  <h4>cellSummary</h4>
                  <p>Calling "inspect" on any Origin mimic will dispatch to "cellSummary", which displays all the cell information about a specific object.</p>

                  <h4>cell</h4>
                  <p>The "cell" method can be used for two different things. The first one is to get access to a value without activating it, and the second is to get access to a cell based on a name that you don't know at the time you're writing the program. The "cell" method takes one argument that is the name of the cell to fetch. The fetching works the same as regular cell lookup, except that activation doesn't happen. This means that a condition will still be signalled if you try to get something that doesn't exist.</p>

                  <pre class="code">
<span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
<span style="color: #449900;">cell</span>(<span style="color: #7777d4;">:x</span>) <span style="color: #a52a2a;">;; 42
</span>
<span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>()
<span style="color: #449900;">cell</span>(<span style="color: #7777d4;">:x</span>) <span style="color: #a52a2a;">;; the method object
</span>
<span style="color: #b0c4de;">name</span> <span style="color: #00bfff;">=</span> <span style="color: #7777d4;">:foo</span>
<span style="color: #449900;">cell</span>(name) <span style="color: #a52a2a;">;; the value of foo</span></pre>
                  
                  <h4>cell=</h4>
                  <p>Just as with "cell", "cell=" can be used to set cells that you don't know the name of at the time of writing the program. As discussed in the chapter on assignment, cell= can also be used to set cells that can't be set in the regular way due to naming strangeness.</p>

                  <h4>cell?</h4>
                  <p>If you're not sure if a cell exists, using "cell?" is the way to find out. Give it a name and it returns true or false depending on if that cell exists.</p>

                  <h4>cellNames</h4>
                  <p>If you want to get the names of all the cells an object contains, you can get that with cellNames. By default, cellNames will only return the names of cells that belong to the receiver, but if an argument of true is sent to the call, the resulting list will contain the names of all cells of all mimics too.</p>

                  <pre class="code">
<span style="color: #0000cd;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
x <span style="color: #b0c4de;">f</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
x cellNames <span style="color: #a52a2a;">;; return [:f]
</span>
x cellNames(<span style="color: #6495ed;">true</span>) <span style="color: #a52a2a;">;; return a long list, including :f</span></pre>

                  <h4>cells</h4>
                  <p>Just like cellNames return the names of all the cells, the "cells" method will return a Dict of all the cells with their values. And just like cellNames, cells take an optional boolean argument on whether to include the cells of mimics too.</p>

                  <pre class="code">
<span style="color: #0000cd;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
x <span style="color: #b0c4de;">f</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
x cells <span style="color: #a52a2a;">;; return {f: 42}
</span>
x cells(<span style="color: #6495ed;">true</span>) <span style="color: #a52a2a;">;; return a large dict, including f: 42</span></pre>

                  <h4>mimics</h4>
                  <p>Returns a list of all direct mimics of the receiver.</p>

                  <h4>mimics?</h4>
                  <p>Takes one object as argument and returns true or false depending on if the argument is anywhere in the receiving objects mimic chain.</p>

                  <h4>message</h4>
                  <p>Takes one symbol argument and creates a new Message mimic with that argument as its name.</p>

                  <h4>Message code</h4>
                  <p>Returns a text that describes the code this message chain represents. It will hide some of the internal shuffling, but operators will be displayed using canonical form.</p>

                  <h4>Message formattedCode</h4>
                  <p>Returns a text that is formatted and indented in a canonical way. This method is used to generate the documentation code for DokGen, among other things.</p>

                  <h4>Message evalArgAt</h4>
                  <p>Takes the index of the argument to evaluate, and the ground to evaluate it on - returns the result of evaluating the argument.</p>

                  <h4>Message fromText</h4>
                  <p>Takes one text argument that should contain Ioke code, and returns the parsed message chain from that code, without evaluating it.</p>

                  <h4>Message doText</h4>
                  <p>Takes one text argument that should contain Ioke code, and returns the result of evaluating that code in the current context.</p>

                  <h4>Message filename</h4>
                  <p>Returns the filename where the receiving message was defined.</p>

                  <h4>Message line</h4>
                  <p>Returns the line number where the receiving message was defined.</p>

                  <h4>Message position</h4>
                  <p>Returns the position in the line where the receiving message was defined.</p>

                  <h4>Message name</h4>
                  <p>Returns the name of the message. The name of the message is what you generally talk about when saying you send a message. It can also be called the selector in other languages.</p>

                  <h4>Message name=</h4>
                  <p>Update the message with a new name. From this point on the message will only have that name, so doing this on a message that is part of an existing message chain will change the behavior of that code:</p>

                  <pre class="code">
<span style="color: #b0c4de;">msg</span> <span style="color: #00bfff;">=</span> <span style="color: #606060;">Message</span> fromText(<span style="color: #0050a0;">"2 + 1"</span>)
msg next <span style="color: #b0c4de;">name</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">"-"</span>
msg code <span style="color: #a52a2a;">;; "2 -(1)"</span></pre>

                  <h4>Message prev</h4>
                  <p>Returns the prev pointer of this message, or nil if no prev pointer exists.</p>

                  <h4>Message prev=</h4>
                  <p>Sets the prev pointer of a message. The new value should be either nil or another message.</p>

                  <h4>Message next</h4>
                  <p>Returns the next pointer of this message, or nil if no next pointer exists.</p>

                  <h4>Message next=</h4>
                  <p>Sets the next pointer of a message. The new value should be either nil or another message.</p>

                  <h4>Message sendTo</h4>
                  <p>Sends a message to an object. It's important to realize that sendTo will not evaluate the whole message chain -- it will only send one message with arguments to an object.</p>
                  
                  <h4>Message keyword?</h4>
                  <p>Returns true if this message is a keyword message, and false otherwise.</p>

                  <p>There are many more methods that can be used to do interesting introspection and reflection in Ioke. The reference documentation includes them all. Most of the interesting stuff can be found on the Message kind.</p>
                </div>

                <div class="chapter">
                  <h2><a name="importing">Importing</a></h2>
                  <p>To import new code into Ioke, the method "use" should be used. The terminology is that you give "use" a name of a module to include, and if that module has already been included it will not be evaluated again. If it has not been included, "use" will try to find the module using several different heuristics. It will add an ".ik" to the name and try to look up a file of that name - but it will also try to look it up without a ".ik", if a full file name has been given. Several different places will be searched, and the exact order and what will be searched can be found by calling the "System loadPath" method. This will return a list of all the places to search for modules. This list can be modified to add more directories to the load path.</p>
                  
                  <p>If a module of the specified name can't be found, a condition will be called.</p>
                </div>

                <div class="chapter">
                  <h2><a name="coreKinds">Core kinds</a></h2>
                  <p>Ioke obviously contains lots of different data types, but there are some that are much more important than others. In this chapter I'll take a look at these and talk above how to work with them correctly.</p>

                  <div class="section">
                    <h3><a name="conditions">Conditions</a></h3>
                    <p>One of the major parts of Ioke is the condition system. Unlike most other programming languages, Ioke doesn't have exceptions. Instead it has conditions, where errors is a specific kind of condition. The condition system comprises several different things. Specifically, the condition system uses the kinds Condition, Restart, Handler and Rescue. Restarts are mostly orthogonal to the rest of the system.</p>

                    <p>The way the condition system work is this. When something happens, a program can elect to signal a condition. This can be done using "signal!", "warn!" or "error!". Both "warn!" and "error!" uses "signal!" under the covers, but do some other things as well. A condition will always be an instance of a condition. Each of these three methods can be called in three different ways. First, you can call them with a text argument. In that case the signalled condition will be the default for that type. (The default for "signal!" is Condition Default. The default for "warn!" is Condition Warning Default and the default for "error!" is Condition Error Default). A new mimic of the default condition will be created, and a cell called text will be set to the text argument. The second variation is to give an instance of an existing condition to one of the methods. In that case that condition will be signalled unmodified. Finally, the third version gives a condition mimic and one or more keyword arguments with data to set on that condition. In that case a mimic of the condition will be created, and then cells with data set based on the arguments.</p>

                    <p>If a signal is not handled, nothing happens.</p>
                    <p>If a warning is not handled, a message will be printed with the text of that warning.</p>
                    <p>If an error is not handled, the debugger will be invoked - if a debugger is available. Otherwise the program will be terminated.</p>

                    <p>A Rescue allow conditions to unwind the stack to the place where the rescue is established. Combining rescues and conditions looks a lot like regular exception handling in other programming languages.</p>

                    <p>A Handler on the other hand will run code in the dynamic context of the place where the condition was signalled. A handler can invoke restarts to handle an error state at the place it happened, and as such doesn't have to actually unwind the stack anywhere. Any number of handlers can run - the last handler to run will be either the last handler, the handler that activates a restart, or the last handler before a valid rescue for that condition.</p>

                    <p>A restart is a way to allow ways of getting back to a valid state. Take the example of referring to a cell that doesn't exist. Before signalling a condition, Ioke will set up restarts so you can provide a value to use in the case a cell doesn't exist. This restart will use that new value and continue execution at the point where it would otherwise have failed.</p>

                    <p>A restart can have a name. If it doesn't have a name it can only be used interactively. You can use findRestart to get hold of the closest restart with a given name. You can invoke a given restart with invokeRestart, which takes either the name of a restart or a restart mimic. Finally, you can get all available restarts using availableRestarts.</p>

                    <p>Both handlers, rescues and restarts are established inside a call to the bind macro. All arguments to this macro need to be either handlers, rescues or restarts, except for the last argument which should be the code to execute.</p>

                    <p>You create a new handler by calling the method "handle". You create a new rescue by calling the method "rescue". You create a new restart by calling the method "restart". These all take funky arguments, so refer to the reference to understand more closely how they work.</p>

                    <p>This small example doesn't necessarily show the power of conditions, but it can give an idea about how it works.</p>

                    <pre class="code">
<span style="color: #a52a2a;">;; to handle any problem
</span><span style="color: #449900;">bind</span>(
  rescue(<span style="color: #6495ed;">fn</span>(c<span style="color: #006666;">,</span> <span style="color: #6495ed;">nil</span>))<span style="color: #006666;">,</span> <span style="color: #a52a2a;">;; do nothing in the rescue
</span>  
  error!(<span style="color: #0050a0;">"This is bad!!"</span>)
)

<span style="color: #a52a2a;">;; to print all conditions happening, but not do anything
</span><span style="color: #449900;">bind</span>(
  handle(<span style="color: #6495ed;">fn</span>(c<span style="color: #006666;">,</span> c <span style="color: #449900;">println</span>))<span style="color: #006666;">,</span>
  
  signal!(<span style="color: #0050a0;">"something"</span>)
  signal!(<span style="color: #0050a0;">"something more"</span>)

  warn!(<span style="color: #0050a0;">"A warning!!"</span>)
)

<span style="color: #a52a2a;">;; rescue either of two conditions
</span><span style="color: #b0c4de;">C1</span> <span style="color: #00bfff;">=</span> <span style="color: #606060;">Condition</span> <span style="color: #606060;">Error</span> <span style="color: #6495ed;">mimic</span>
<span style="color: #b0c4de;">C2</span> <span style="color: #00bfff;">=</span> <span style="color: #606060;">Condition</span> <span style="color: #606060;">Error</span> <span style="color: #6495ed;">mimic</span>

<span style="color: #449900;">bind</span>(
  rescue(<span style="color: #606060;">C1</span><span style="color: #006666;">,</span> <span style="color: #606060;">C2</span><span style="color: #006666;">,</span> <span style="color: #6495ed;">fn</span>(c<span style="color: #006666;">,</span> <span style="color: #0050a0;">"got an error: #{c}"</span> <span style="color: #449900;">println</span>))<span style="color: #006666;">,</span>
  
  error!(<span style="color: #606060;">C1</span>)
)


<span style="color: #a52a2a;">;; invoke a restart when no such cell is signaled
</span><span style="color: #449900;">bind</span>(
  handle(<span style="color: #606060;">Condition</span> <span style="color: #606060;">Error</span> <span style="color: #606060;">NoSuchCell</span><span style="color: #006666;">,</span> <span style="color: #6495ed;">fn</span>(c<span style="color: #006666;">,</span> invokeRestart(<span style="color: #7777d4;">:useValue</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">42</span>)))<span style="color: #006666;">,</span>

  blarg <span style="color: #449900;">println</span>) <span style="color: #a52a2a;">;; will print 42
</span>

<span style="color: #a52a2a;">;; establish a restart
</span><span style="color: #449900;">bind</span>(
  <span style="color: #449900;">restart</span>(something<span style="color: #006666;">,</span> <span style="color: #6495ed;">fn</span>(<span style="color: #00bfff;">+</span>args<span style="color: #006666;">,</span> args <span style="color: #449900;">println</span>))<span style="color: #006666;">,</span>
  
  invokeRestart(<span style="color: #7777d4;">:something</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span>)
)</pre>
 
                    <p>The code above shows several different things you can do with the condition system. It is a very powerful system, so I recommend trying to understand it. It lies at the core of many things in Ioke, and some parts will not make sense without a deep understanding of conditions. For more information on what such a system is capable of, look for documentation about the Common Lisp condition system, which has been a heavy influence on Ioke. Also, the debugger in IIk uses the condition system to implement its functionality.</p>

                    <p>There are many conditions defined in the core of Ioke, and they are used by the implementation to signal error conditions of different kinds. Refer to the reference to see which conditions are available.</p>
                  </div>

                  <div class="section">
                    <h3><a name="text">Text</a></h3>
                    <p>In Ioke, the equivalent of Strings in other languages are called Text. This better describes the purpose of the type. Ioke Text is immutable. All operations that would change the text returns a new object instead. If you are used to Java strings or Ruby strings, then most operation available on Ioke Texts will not come as a surprise.</p>

                    <p>To create a new Text, you use the literal syntax as described in the syntax chapter. You can use interpolation to include dynamic data.</p>

                    <p>You can do several things with Ioke text. These examples should show some of the methods:</p>
                    <pre class="code">
<span style="color: #a52a2a;">;; repeat a text several times
</span><span style="color: #0050a0;">"foo"</span> <span style="color: #00bfff;">*</span> <span style="color: #0050a0;">3</span>  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "foofoofoo"
</span>
<span style="color: #a52a2a;">;; concatenate two texts
</span><span style="color: #0050a0;">"foo"</span> <span style="color: #00bfff;">+</span> <span style="color: #0050a0;">"bar"</span>  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "foobar"
</span>
<span style="color: #a52a2a;">;; get the character at a specific index
</span><span style="color: #0050a0;">"foo"</span>[<span style="color: #0050a0;">1</span>]  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 111
</span>
<span style="color: #a52a2a;">;; get a subset of text
</span><span style="color: #0050a0;">"foo"</span>[<span style="color: #0050a0;">1..1</span>]  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "o"
</span><span style="color: #0050a0;">"foo"</span>[<span style="color: #0050a0;">0..1</span>]  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "fo"
</span><span style="color: #0050a0;">"foo"</span>[<span style="color: #0050a0;">0...1</span>]  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "f"
</span>
<span style="color: #0050a0;">"foxtrot"</span>[<span style="color: #0050a0;">1</span><span style="color: #00bfff;">..-</span><span style="color: #0050a0;">1</span>] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "oxtrot"
</span><span style="color: #0050a0;">"foxtrot"</span>[<span style="color: #0050a0;">1</span><span style="color: #00bfff;">...-</span><span style="color: #0050a0;">1</span>] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "oxtro"
</span>
<span style="color: #a52a2a;">;; is a text empty?
</span><span style="color: #0050a0;">"foo"</span> <span style="color: #449900;">empty?</span>  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> false
</span><span style="color: #0050a0;">""</span> <span style="color: #449900;">empty?</span>  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>
<span style="color: #a52a2a;">;; the length of the text
</span><span style="color: #0050a0;">"foo"</span> length  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 3
</span><span style="color: #0050a0;">""</span> length  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 0
</span>
<span style="color: #a52a2a;">;; replace the first occurance of something with something else
</span><span style="color: #0050a0;">"hello fox fob folk"</span> replace(<span style="color: #0050a0;">"fo"</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">"ba"</span>)
  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "hello bax fob folk"
</span>
<span style="color: #a52a2a;">;; replace all occurances of something with something else
</span><span style="color: #0050a0;">"hello fox fob folk"</span> replaceAll(<span style="color: #0050a0;">"fo"</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">"ba"</span>)
  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "hello bax bab balk"
</span>
<span style="color: #a52a2a;">;; split around a text
</span><span style="color: #0050a0;">"foo bar bax"</span> split(<span style="color: #0050a0;">" "</span>)
  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> ["foo", "bar", "bax"]</span></pre>

                    <p>The Text kind contains lots of useful functionality like this. The purpose is to make it really easy to massage text of any kind.</p>

                    <p>One important tool for doing that is the "format" method. This is a mix between C printf and Common Lisp format. At the moment, it only contains a small amount of functionality, but it can still be very convenient. Specifically you can print each element in a list directly by using format, instead of concatenating text yourself.</p>

                    <p>The "format" method takes format specifies that begin with %, and then inserts one of its arguments in different ways depending on what kind of format specifier is used.</p>

                    <p>Some examples of format follows:</p>
                    <pre class="code">
<span style="color: #a52a2a;">;; insert simple value as text
</span><span style="color: #0050a0;">"%s"</span> format(<span style="color: #0050a0;">123</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "123"
</span>
<span style="color: #a52a2a;">;; insert value right justified by 6
</span><span style="color: #0050a0;">"%6s"</span> format(<span style="color: #0050a0;">123</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "   123"
</span>
<span style="color: #a52a2a;">;; insert value left justified by 6
</span><span style="color: #0050a0;">"%-6s"</span> format(<span style="color: #0050a0;">123</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "123   "
</span>
<span style="color: #a52a2a;">;; insert two values
</span><span style="color: #0050a0;">"%s: %s"</span> format(<span style="color: #0050a0;">123</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">321</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "123: 321"
</span>
<span style="color: #a52a2a;">;; insert a list of values formatted the same
</span><span style="color: #0050a0;">"%[%s, %]\n"</span> format([<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span><span style="color: #0050a0;">2</span><span style="color: #006666;">,</span><span style="color: #0050a0;">3</span>])
  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "1, 2, 3, \n"
</span>
<span style="color: #a52a2a;">;; insert splatted values from a list
</span><span style="color: #0050a0;">"wow: %*[%s: %s %]"</span> format([[<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span><span style="color: #0050a0;">2</span>]<span style="color: #006666;">,</span>[<span style="color: #0050a0;">2</span><span style="color: #006666;">,</span><span style="color: #0050a0;">3</span>]<span style="color: #006666;">,</span>[<span style="color: #0050a0;">3</span><span style="color: #006666;">,</span><span style="color: #0050a0;">4</span>]])
  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "wow: 1: 2 2: 3 3: 4 "</span></pre>

                  </div>

                  <div class="section">
                    <h3><a name="numbers">Numbers</a></h3>
                    <p>As mentioned in the section on syntax, Ioke supports decimal numbers, integers and ratios. A Ratio will be created when two integeres can't be divided evenly. A Ratio will always use the GCD. In most cases Ratios, Decimals and Integers can interact with each other was would be expected. The one thing that might surprise people is that Ioke doesn't have any inexact floating point data type. Instead, decimals are exact and can have any size. The means they are well suited to represent such things as money, since operations will always have well defined results.</p>

                    <p>All expected math works fine on Ioke numbers. The reference for numbers more closely specify what is possible. One thing to notice is that the % operator implements modulus, not remainder. This might be unintuitive for some developers. What that means is that it is not an error to ask for the modulus of 0: "13 % 0", since there is no division necessary in this operation.</p>

                    <p>In addition to the above, Integers have the "times" method described earlier. It can also return the successor and predecessor of itself with the "pred" and "succ" methods.</p>
                  </div>

                  <div class="section">
                    <h3><a name="lists">Lists</a></h3>
                    <p>Ioke has lists that expand to the size needed. These lists can be created using a simple literal syntax. They can contain any kind of element, including itself (although don't try to print such a list). Ioke lists mixin in the Enumerable mixin, which gives it quite powerful capabilities.</p>

                    <p>A list can be created using the "list" or "[]" methods:</p>
                    <pre class="code">
<span style="color: #a52a2a;">;; an empty list
</span>[]

<span style="color: #a52a2a;">;; the same list created in two different ways
</span><span style="color: #449900;">list</span>(<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span>)
[<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span>]

<span style="color: #a52a2a;">;; a list with different elements
</span>[<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">"one"</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">:one</span>]</pre>
                    
                    <p>Except for the Enumerable methods, List also defines many other methods that can be highly useful. Some examples are shown below:</p>
                    <pre class="code">
<span style="color: #b0c4de;">l</span> <span style="color: #00bfff;">=</span> [<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span>]

<span style="color: #a52a2a;">;; add two lists together
</span>l <span style="color: #00bfff;">+</span> l <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> [1, 2, 3, 1, 2, 3]
</span>
<span style="color: #a52a2a;">;; return the difference of two lists
</span>l <span style="color: #00bfff;">-</span> [<span style="color: #0050a0;">2</span>] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> [1, 3]
</span>
<span style="color: #a52a2a;">;; add a new value to a list
</span>l &lt;&lt; <span style="color: #0050a0;">42</span>
l <span style="color: #00bfff;">==</span> [<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">42</span>] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>
<span style="color: #a52a2a;">;; get a specific element from the list
</span>l[<span style="color: #0050a0;">0</span>]  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 1
</span>
<span style="color: #a52a2a;">;; -1 returns the last, -2 the next to last
</span>l[<span style="color: #00bfff;">-</span><span style="color: #0050a0;">1</span>] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 42
</span>
<span style="color: #a52a2a;">;; an index outside the boundaries return nil
</span>l[<span style="color: #0050a0;">10</span>] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> nil
</span>
<span style="color: #a52a2a;">;; assign a new value
</span>l[<span style="color: #0050a0;">3</span>] <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">40</span>
l <span style="color: #00bfff;">==</span> [<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span><span style="color: #0050a0;">2</span><span style="color: #006666;">,</span><span style="color: #0050a0;">3</span><span style="color: #006666;">,</span><span style="color: #0050a0;">40</span>] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>
l[<span style="color: #00bfff;">-</span><span style="color: #0050a0;">1</span>] <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">39</span>
l <span style="color: #00bfff;">==</span> [<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span><span style="color: #0050a0;">2</span><span style="color: #006666;">,</span><span style="color: #0050a0;">3</span><span style="color: #006666;">,</span><span style="color: #0050a0;">39</span>] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>
<span style="color: #a52a2a;">;; assign an out of bounds value
</span>l[<span style="color: #0050a0;">10</span>] <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">13</span>
l <span style="color: #00bfff;">==</span> [<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span><span style="color: #0050a0;">2</span><span style="color: #006666;">,</span><span style="color: #0050a0;">3</span><span style="color: #006666;">,</span><span style="color: #0050a0;">39</span><span style="color: #006666;">,</span><span style="color: #6495ed;">nil</span><span style="color: #006666;">,</span><span style="color: #6495ed;">nil</span><span style="color: #006666;">,</span><span style="color: #6495ed;">nil</span><span style="color: #006666;">,</span><span style="color: #6495ed;">nil</span><span style="color: #006666;">,</span><span style="color: #6495ed;">nil</span><span style="color: #006666;">,</span><span style="color: #6495ed;">nil</span><span style="color: #006666;">,</span><span style="color: #0050a0;">13</span>]
  <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>
<span style="color: #a52a2a;">;; at and at= is the same as [] and []]
</span>l at(<span style="color: #0050a0;">0</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 1
</span>
<span style="color: #a52a2a;">;; empty the list
</span>l clear!
l <span style="color: #00bfff;">==</span> [] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>
<span style="color: #a52a2a;">;; follows the each protocol
</span>l each(<span style="color: #449900;">println</span>)

<span style="color: #a52a2a;">;; is empty?
</span>l <span style="color: #449900;">empty?</span> <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>
<span style="color: #a52a2a;">;; does it include an element?
</span>l include?(<span style="color: #7777d4;">:foo</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> false
</span>
<span style="color: #a52a2a;">;; the last element
</span>l last <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> nil
</span>[<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span>] last <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 2
</span>
<span style="color: #a52a2a;">;; the length
</span>[<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span>] length <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 2
</span>
<span style="color: #a52a2a;">;; first value
</span>[<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span>] first <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 1
</span>
<span style="color: #a52a2a;">;; rest except for first
</span>[<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span>] rest <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> [2, 3]
</span>
<span style="color: #a52a2a;">;; returns a new sorted list
</span>[<span style="color: #0050a0;">3</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">1</span>] sort <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> [1, 2, 3]
</span>
<span style="color: #a52a2a;">;; sorts in place
</span><span style="color: #b0c4de;">l</span> <span style="color: #00bfff;">=</span> [<span style="color: #0050a0;">3</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">1</span>]
l sort!
l <span style="color: #00bfff;">==</span> [<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span>] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span></pre>
                  </div>

                  <div class="section">
                    <h3><a name="dicts">Dicts</a></h3>
                    <p>A Dict is a dictionary of key-value mappings. The mappings are unordered, and there can only ever be one key with the same value. Any kind of Ioke object can be used as a key. There is no problem with having the value for different keys. The default implementation of Dict uses a hash-based implementation. That's not necessarily always true for all dicts. The iteration order is not necessarily stable either, so don't write code that depends on it.</p>

                    <p>Creating a dict is done using either the "dict" or the "{}" methods. Both of these expect either keyword arguments or mimics of Pair. If keyword arguments, these keywords will be used as symbol keys. That's the most common thing, so it makes sense to have that happen automatically. Dicts also try to print themselves that way.</p>
                    
                    <pre class="code">
<span style="color: #449900;">dict</span>(<span style="color: #b0c4de;">1</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #b0c4de;">3</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">4</span>)

<span style="color: #a52a2a;">;; these two are the same
</span><span style="color: #449900;">dict</span>(<span style="color: #7777d4;">foo:</span> <span style="color: #0050a0;">"bar"</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">baaz:</span> <span style="color: #0050a0;">"quux"</span>)
<span style="color: #449900;">dict</span>(<span style="color: #b0c4de;">:foo</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">"bar"</span><span style="color: #006666;">,</span> <span style="color: #b0c4de;">:baaz</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">"quux"</span>)

{<span style="color: #b0c4de;">1</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #b0c4de;">3</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">4</span>}

<span style="color: #a52a2a;">;; these two are the same
</span>{<span style="color: #7777d4;">foo:</span> <span style="color: #0050a0;">"bar"</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">baaz:</span> <span style="color: #0050a0;">"quux"</span>}
{<span style="color: #b0c4de;">:foo</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">"bar"</span><span style="color: #006666;">,</span> <span style="color: #b0c4de;">:baaz</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">"quux"</span>}

<span style="color: #a52a2a;">;; the formats can be combined:
</span>{<span style="color: #b0c4de;">1</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">foo:</span> <span style="color: #0050a0;">42</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">"bar"</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">"qux"</span>}</pre>

                    <p>The literal Pair syntax (using =&gt;) will not necessarily instantiate real pairs for this.</p>

                    <p>Dicts mixes in Enumable. When using each, what will be yielded is mimics of Pair, where the first value will be the key and the second will be value. Just like Lists, Dicts have several useful methods in themselves:</p>

                    <pre class="code">
<span style="color: #b0c4de;">d</span> <span style="color: #00bfff;">=</span> {<span style="color: #7777d4;">one:</span> <span style="color: #0050a0;">"two"</span><span style="color: #006666;">,</span> <span style="color: #b0c4de;">3</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">4</span>}

<span style="color: #a52a2a;">;; lookup with [], "at" works the same
</span>d[<span style="color: #7777d4;">:one</span>] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "two"
</span>d[<span style="color: #7777d4;">:two</span>] <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> nil
</span>d[<span style="color: #0050a0;">3</span>]    <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 4
</span>d[<span style="color: #0050a0;">4</span>]    <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> nil
</span>
<span style="color: #a52a2a;">;; assign values with []=
</span>d[<span style="color: #7777d4;">:one</span>] <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">"three"</span>
d[<span style="color: #7777d4;">:new</span>] <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">"wow!"</span>

d <span style="color: #00bfff;">==</span> {<span style="color: #7777d4;">one:</span> <span style="color: #0050a0;">"three"</span><span style="color: #006666;">,</span> <span style="color: #b0c4de;">3</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">4</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">new:</span> <span style="color: #0050a0;">"wow!"</span>}

<span style="color: #a52a2a;">;; iterate over it
</span>d each(value <span style="color: #449900;">println</span>)

<span style="color: #a52a2a;">;; get all keys
</span>d keys <span style="color: #00bfff;">==</span> set(<span style="color: #7777d4;">:one</span><span style="color: #006666;">,</span> <span style="color: #7777d4;">:new</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span>)</pre>

                  </div>

                  <div class="section">
                    <h3><a name="rangesAndPairs">Ranges and Pairs</a></h3>
                    <p>Both ranges and pairs tie two values together. They also have literal syntax to create them, since they are very useful in many circumstances.</p>

                    <p>A Range defines two endpoints. A Range is Enumerable and you can also check for membership. It's also convenient to send Ranges to the "List []" method. A Range can be exclusive or inclusive. If it's inclusive it includes the end value, and if it is exclusive it doesn't.</p>
                    
                    <pre class="code">
<span style="color: #a52a2a;">;; literal syntax for inclusive range
</span><span style="color: #0050a0;">1..10</span>

<span style="color: #a52a2a;">;; literal syntax for exclusive range
</span><span style="color: #0050a0;">1...10</span>

<span style="color: #a52a2a;">;; check for membership
</span>(<span style="color: #0050a0;">1..10</span>) <span style="color: #00bfff;">===</span> <span style="color: #0050a0;">5</span> <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>(<span style="color: #0050a0;">1..10</span>) <span style="color: #00bfff;">===</span> <span style="color: #0050a0;">10</span> <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>(<span style="color: #0050a0;">1..10</span>) <span style="color: #00bfff;">===</span> <span style="color: #0050a0;">11</span> <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> false
</span>
(<span style="color: #0050a0;">1...10</span>) <span style="color: #00bfff;">===</span> <span style="color: #0050a0;">5</span> <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>(<span style="color: #0050a0;">1...10</span>) <span style="color: #00bfff;">===</span> <span style="color: #0050a0;">10</span> <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> false
</span>(<span style="color: #0050a0;">1...10</span>) <span style="color: #00bfff;">===</span> <span style="color: #0050a0;">11</span> <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> false
</span>
<span style="color: #a52a2a;">;; get the from value
</span>(<span style="color: #0050a0;">1..10</span>) from <span style="color: #00bfff;">==</span> <span style="color: #0050a0;">1</span> <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>(<span style="color: #0050a0;">1...10</span>) from <span style="color: #00bfff;">==</span> <span style="color: #0050a0;">1</span> <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>
<span style="color: #a52a2a;">;; get the to value
</span>(<span style="color: #0050a0;">1..10</span>) to <span style="color: #00bfff;">==</span> <span style="color: #0050a0;">10</span> <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>(<span style="color: #0050a0;">1...10</span>) to <span style="color: #00bfff;">==</span> <span style="color: #0050a0;">10</span> <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>
<span style="color: #a52a2a;">;; is this range exclusive?
</span>(<span style="color: #0050a0;">1..10</span>) exclusive? <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> false
</span>(<span style="color: #0050a0;">1...10</span>) exclusive? <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>
<span style="color: #a52a2a;">;; is this range inclusive?
</span>(<span style="color: #0050a0;">1..10</span>) inclusive? <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> true
</span>(<span style="color: #0050a0;">1...10</span>) inclusive? <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> false</span></pre>
                    

                    <p>A Pair represent a combination of two values. They doesn't have to be of the same kind. They can have any kind of relationship. Since Pair's are often used to represent Dicts, it is very useful to refer to the first value as the "key", and the second value as "value".</p>

                    <pre class="code">
<span style="color: #a52a2a;">;; literal syntax for a pair
</span><span style="color: #0050a0;">"foo"</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">"bar"</span>

<span style="color: #a52a2a;">;; getting the first value
</span>(<span style="color: #0050a0;">"foo"</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">"bar"</span>) first <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "foo"
</span>(<span style="color: #0050a0;">"foo"</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">"bar"</span>) key <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "foo"
</span>
<span style="color: #a52a2a;">;; getting the second value
</span>(<span style="color: #0050a0;">"foo"</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">"bar"</span>) second <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "bar"
</span>(<span style="color: #0050a0;">"foo"</span> <span style="color: #00bfff;">=</span>&gt; <span style="color: #0050a0;">"bar"</span>) value <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> "bar"
</span></pre>                    
                  </div>

                  <div class="section">
                    <h3><a name="enumerable">Enumerable</a></h3>
                    <p>One of the most important mixins in Ioke is Mixins Enumerable - the place where most of the collection functionality is available. The contract for any kind that wants to be Enumerable is that it should implement each in the manner described earlier. If it does that it can mixin Enumerable and get access to all the methods defined in it. I'm not going to show all the available methods, but just a few useful examples here. Note that any method name that ends with Fn takes a block instead of a raw message chain.</p>

                    <p>Almost all methods in Enumerable takes variable amounts of arguments and does different things depending on how many arguments are provided. The general rule is that if there is only one argument, it should be a message chain, and if there is two or more arguments the last one should be code, and the rest should be names of arguments to use in that code.</p>

                    <p>Mapping a collection into a another collection can be done using map or mapFn. These are aliased as collect and collectFn too.</p>
                    <pre class="code">
<span style="color: #b0c4de;">l</span> <span style="color: #00bfff;">=</span> [<span style="color: #0050a0;">10</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">20</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">30</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">40</span>]

<span style="color: #a52a2a;">;; mapping into text
</span>l map(<span style="color: #449900;">asText</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> ["10", "20", "30", "40"]
</span>l map(n<span style="color: #006666;">,</span> n <span style="color: #449900;">asText</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> ["10", "20", "30", "40"]
</span>
<span style="color: #a52a2a;">;; exponentiation
</span>l map(<span style="color: #00bfff;">**</span><span style="color: #0050a0;">2</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> [100, 400, 900, 1600]
</span>l map(n<span style="color: #006666;">,</span> n<span style="color: #00bfff;">*</span>n) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> [100, 400, 900, 1600]</span></pre>

                    <p>Filtering the contents of a collection can be done using select, which is aliased as filter and findAll.</p>
                    <pre class="code">
<span style="color: #a52a2a;">;; with no arguments, return all true things
</span>[<span style="color: #6495ed;">nil</span><span style="color: #006666;">,</span> <span style="color: #6495ed;">false</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">13</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">42</span>] select <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> [13, 42]
</span>
<span style="color: #b0c4de;">l</span> <span style="color: #00bfff;">=</span> [<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">4</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">5</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">6</span>]

<span style="color: #a52a2a;">;; all elements over 3
</span>l select(&gt;<span style="color: #0050a0;">3</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> [4, 5, 6]
</span>l select(n<span style="color: #006666;">,</span> n&gt;<span style="color: #0050a0;">3</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> [4, 5, 6]</span></pre>

                    <p>A very common operation is create one object based on the contents of a collection. This operation has different names in different languages. In Ioke it is called inject, but it is aliased as reduce and fold.</p>
                    <pre class="code">
<span style="color: #b0c4de;">l</span> <span style="color: #00bfff;">=</span> [<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">2</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">3</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">4</span><span style="color: #006666;">,</span> <span style="color: #0050a0;">5</span>]

<span style="color: #a52a2a;">;; inject around a message chain
</span>l inject(<span style="color: #00bfff;">+</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 15
</span>l inject(<span style="color: #00bfff;">*</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 120
</span>
<span style="color: #a52a2a;">;; with one arg
</span>l inject(n<span style="color: #006666;">,</span> <span style="color: #00bfff;">*</span>n) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 120
</span>l inject(n<span style="color: #006666;">,</span> <span style="color: #00bfff;">+</span>n<span style="color: #00bfff;">*</span><span style="color: #0050a0;">2</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 29
</span>
<span style="color: #a52a2a;">;; with two args
</span>l inject(sum<span style="color: #006666;">,</span> n<span style="color: #006666;">,</span> sum<span style="color: #00bfff;">*</span>n) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 120
</span>l inject(sum<span style="color: #006666;">,</span> n<span style="color: #006666;">,</span> sum<span style="color: #00bfff;">*</span><span style="color: #0050a0;">2</span> <span style="color: #00bfff;">+</span> n<span style="color: #00bfff;">*</span><span style="color: #0050a0;">3</span>) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 139
</span>
<span style="color: #a52a2a;">;; with four args
</span>l inject(<span style="color: #0050a0;">1</span><span style="color: #006666;">,</span> sum<span style="color: #006666;">,</span> n<span style="color: #006666;">,</span> sum<span style="color: #00bfff;">*</span>n) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 120
</span>l inject(<span style="color: #0050a0;">10</span><span style="color: #006666;">,</span> sum<span style="color: #006666;">,</span> n<span style="color: #006666;">,</span> sum<span style="color: #00bfff;">*</span>n) <span style="color: #a52a2a;">;; =</span>&gt;<span style="color: #a52a2a;"> 1200</span></pre>
                  </div>

                  <div class="section">
                    <h3><a name="regexps">Regexps</a></h3>
                    <p>Regular expressions allow the matching of text against an abstract pattern. Ioke uses the JRegex engine to implement regular expressions. This means Ioke support quite advanced expressions. At the moment, Ioke only allows matching against an expression and getting a yes or no answer, though. This is done using the "~=" method. When the regular expression support has been expanded, this section will include information about everything that can be done using them.</p>
                  </div>

                  <div class="section">
                    <h3><a name="filesystem">FileSystem</a></h3>
                    <p>The FileSystem kind allow access to functionality in the file system. It is the entry point to any manipulation of files and directories, and it can also be uesd to get listings of existing files. The reference includes good information about the existing methods in the FileSystem kind.</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="libraries">Libraries</a></h2>
                  <p>TODO: write content</p>

                  <div class="section">
                    <h3><a name="iik">IIk</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="ispec">ISpec</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="dokgen">DokGen</a></h3>
                    <p>TODO: write content</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="missing">What is missing</a></h2>
                  <p>TODO: write content</p>
                </div>

                <div class="chapter">
                  <h2><a name="futurePlans">Future plans</a></h2>
                  <p>TODO: write content</p>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    </div>
  </body>
</html>
