<!DOCTYPE html 
PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Ioke &raquo; Programming Guide</title>
    <link rel="stylesheet" href="style/ioke-style.css" type="text/css" media="screen" />
  </head>
  <body>
    <div id="logo">
      <a href="index.html">
        <img src="img/IokeLogo.png" alt="Ioke Logo" width="118" height="115" border="0"/>
      </a>
    </div>

    <div id="header">
      Programming Guide
    </div>

    <div id="content">
    <table cellpadding="0" cellspacing="0" border="0">
      <tr>
        <td valign="top" style="background: #E6EEEE;">
            <table cellpadding="0" cellspacing="0" border="0" id="menu">
              <tr>
                <td>
                  <span class="menuItem">
                    <a href="index.html" class="unselectedMenuItem">About Ioke</a>
                  </span>
                </td>
              </tr>
              <tr>
                <td style="height:.4em"></td>
              </tr>

              <tr>
                <td>
                  <span class="menuItem">
                    <a href="guide.html" class="selectedMenuItem">Guide</a>
                  </span>
                </td>
              </tr>
              <tr>
                <td style="height:.4em"></td>
              </tr>

              <tr>
                <td>
                  <span class="menuItem">
                    <a href="download.html" class="unselectedMenuItem">Download</a>
                  </span>
                </td>
              </tr>
              <tr>
                <td style="height:.4em"></td>
              </tr>

              <tr>
                <td>
                  <span class="menuItem">
                    <a href="http://ioke.kenai.com" class="unselectedMenuItem">Project page</a>
                  </span>
                </td>
              </tr>
              <tr>
                <td style="height:.4em"></td>
              </tr>

              <tr>
                <td>
                  <span class="menuItem">
                    <a href="dok/index.html" class="unselectedMenuItem">Reference</a>
                  </span>
                </td>
              </tr>
              <tr>
                <td style="height:.4em"></td>
              </tr>
            </table>
        </td>
        <td>
          <table cellpadding="0" cellspacing="0" border="0" style="width:50em">
            <tr>
              <td style="width:10em"></td>
              <td>
                <ol>
                  <li>
                    <a href="#introduction">Introduction</a>
                    <ol>
                      <li>
                        <a href="#vision">Vision</a>
                      </li>
                      <li>
                        <a href="#gettingStarted">Getting started</a>
                        <ol>
                          <li>
                            <a href="#runningScripts">Running scripts</a>
                          </li>
                          <li>
                            <a href="#interactive">Interactive mode</a>
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#syntax">Syntax</a>
                    <ol>
                      <li>
                        <a href="#literals">Literal values</a>
                        <ol>
                          <li>
                            <a href="#literalText">Text</a>
                          </li>
                          <li>
                            <a href="#literalRegexps">Regular expressions</a>
                          </li>
                          <li>
                            <a href="#literalIntegers">Integers</a>
                          </li>
                          <li>
                            <a href="#literalDecimals">Decimals</a>
                          </li>
                          <li>
                            <a href="#literalSymbols">Symbols</a>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <a href="#operatorShuffling">Operator shuffling</a>
                      </li>
                      <li>
                        <a href="#assignmentShuffling">Assignment shuffling</a>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#executionModel">Execution model</a>
                  </li>

                  <li>
                    <a href="#objects">Objects</a>
                    <ol>
                      <li>
                        <a href="#base">Base</a>
                      </li>
                      <li>
                        <a href="#ground">Ground</a>
                      </li>
                      <li>
                        <a href="#origin">Origin</a>
                      </li>
                      <li>
                        <a href="#defaultBehavior">DefaultBehavior</a>
                      </li>
                      <li>
                        <a href="#nilTrueFalse">nil, true, false</a>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#assignment">Assignment</a>
                  </li>

                  <li>
                    <a href="#controlFlow">Control flow</a>
                    <ol>
                      <li>
                        <a href="#comparison">Comparison</a>
                      </li>
                      <li>
                        <a href="#conditionals">Conditionals</a>
                      </li>
                      <li>
                        <a href="#iteration">Iteration</a>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#code">Code</a>
                    <ol>
                      <li>
                        <a href="#methods">Methods</a>
                      </li>
                      <li>
                        <a href="#macros">Macros</a>
                      </li>
                      <li>
                        <a href="#blocks">Blocks</a>
                      </li>
                      <li>
                        <a href="#messageChains">Message chains</a>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#introspection">Introspection and reflection</a>
                  </li>

                  <li>
                    <a href="#importing">Importing</a>
                  </li>

                  <li>
                    <a href="#coreKinds">Core kinds</a>
                    <ol>
                      <li>
                        <a href="#conditions">Conditions</a>
                      </li>
                      <li>
                        <a href="#text">Text</a>
                      </li>
                      <li>
                        <a href="#symbols">Symbols</a>
                      </li>
                      <li>
                        <a href="#numbers">Numbers</a>
                      </li>
                      <li>
                        <a href="#lists">Lists</a>
                      </li>
                      <li>
                        <a href="#dicts">Dicts</a>
                      </li>
                      <li>
                        <a href="#rangesAndPairs">Ranges and Pairs</a>
                      </li>
                      <li>
                        <a href="#enumerable">Enumerable</a>
                      </li>
                      <li>
                        <a href="#regexps">Regexps</a>
                      </li>
                      <li>
                        <a href="#filesystem">FileSystem</a>
                      </li>
                    </ol>
                  </li>

                  <li>
                    <a href="#libraries">Libraries</a>
                    <ol>
                      <li>
                        <a href="#iik">IIk</a>
                      </li>
                      <li>
                        <a href="#ispec">ISpec</a>
                      </li>
                      <li>
                        <a href="#dokgen">DokGen</a>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <a href="#missing">What is missing</a>
                  </li>
                  <li>
                    <a href="#futurePlans">Future plans</a>
                  </li>
                </ol>

                <hr/>

                <div class="chapter">
                  <h2><a name="introduction">Introduction</a></h2>
                  <p>Ioke is a general purpose language. It is a strongly typed, extremely dynamic, prototype object oriented language. It is homoiconic and it's closest ancestors is Io, Smalltalk, Ruby and Lisp - but it's quite a distance from all of them. It looks a lot like Io, to a limit.</p>

                  <p>Ioke is targeted at the Java Virtual Machine and is tightly integrated with the platform. Why the JVM? It's available everywhere, it gives severeal important features such as world class garbage collectors, capable thread schedulers and an amazing JIT compiler. All of these are things that server Ioke well, without requiring direct development resources from the Ioke team. Access to the Java platform also means access to all existing libraries and functionality, with all that entails. The JVM is just a very pragmatic choice.</p>

                  <p>You're probably reading this guide at <a href="http://ioke.org/guide.html">ioke.org</a>. That is the official home of the project, although some of the project functionality is hosted at <a href="http://ioke.kenai.org">Kenai</a>, where such things as mailing lists and a bug tracker is available. The canonical source repository for Ioke exists at GitHub, at <a href="http://github.org/olabini/ioke/tree/master">http://github.org/olabini/ioke/tree/master</a>.</p>

                  <p>The current version of Ioke is called Ioke 0. The naming of Ioke will change regularily with major revisions. There are two different versions in play here. Ioke 0 is the name and version of the language and core libraries. The initial implementation for Ioke 0 is called ikJVM 0.1.0, and the version numbers are not interdependent. The next major version of Ioke will be called Ioke S, and you can find information about it in the chapter on <a href="#futurePlans">future plans</a>.</p>

                  <p>This programming guide -- together with the reference for your current version -- should be the complete document needed to understand Ioke 0, how to program in it, how to understand the names and concepts used, and also to give an initial inkling on what I think is good taste.</p>

                  <p>Note that I will use many names that aren't necessarily the same as the ones traditional programming languages use. These names will be made clear sooner or later in this document, but it might help some to jump forward to <a href="#objects">Objects</a>, skim that bit, and then start over once words like Origin, cell and mimic make sense.</p>

                  <div class="section">
                    <h3><a name="vision">Vision</a></h3>

                    <p>The evolution of programming languages is a steady progression of finding new ways to express abstractions naturally - in a way that doesn't stray to far away from the smaller details. A programming language have to make it possible to abstract a way common things, while making it easy to customize these abstractions in very detailed ways. A programming language should be able to do this well without sacrificing readability and understandability. This tension lies at the core of programming.</p>

                    <p>How do you create a language that makes it easy to express powerful concepts in a succinct way, while still making it easy to maintain and work with after the fact, without turning it into a new compression mode? How do make it easy for a programmer to express high level abstractions that are abstractions of abstractions of abstractions?</p>

                    <p>There are many open problems in programming language design. Concurrency is one of them, performance another. These are two areas Ioke does not address. Instead, Ioke is a remodeling of the core concepts and ideas embodied in other programming languages.</p>

                    <p>Are still Lisp and Smalltalk the most powerful languages around, or are there ways of providing more expressiveness without sacrificing understandability? Is there a way to combine all the lessons learned from languages like Ruby and Python, and patch them back into a Lisp and Smalltalk core? Is it possible to do this while taking some of the benefits of Io? Can a language be both small, regular, homoiconic, reflective and easy to understand? I hope that Ioke is just that.</p>

                    <p>Simplicity doesn't mean lack of power. Small, simple, orthogonal functionality can be more powerful than larger, complicated abstractions that doesn't fit together.</p>

                    <p>Io explicitly states that the goal of the language is to refocus attention on expressiveness, and with Ioke I want to take that philosophy one step further.</p>

                    <p>It's important to realize that an experiment like this doesn't necessarily have to mean the language can't be used for real projects. By wedding Ioke to the Java Virtual Machine, I make it easy to get access to good libraries and existing implementations on most platforms. In that way, Ioke can be used to create real systems, even though the ecosystem will initially be very small. And I think that this is necessary. How can you know if a language really is worthwhile or not, if you can't use it as a general purpose programming language? The Java platform makes this possible.</p>
                  </div>

                  <div class="section">
                    <h3><a name="gettingStarted">Getting started</a></h3>
                    <p>Ioke is very easy to get started with. The first step is to download a package. Which one you choose depends on what platform you're on, and whether you want to build Ioke yourself, or just start using it. This guide will only cover using a prebuilt version. Go to the download page at <a href="http://ioke.org/download.html">http://ioke.org/download.html</a>, and download one of the distributions. At the time of writing the full version of Ioke is Ioke 0 ikJVM 0.1.0. Choose the latest download in the 0.1-series for this document to apply. In later revisions of the document, any major change will be noted inline.</p>

                    <p>Once you have downloaded the distribution, you need to unpack it somewhere, and finally add the bin-directory to your PATH environment variable. There is also a jar-download that can be run directly. If you choose this option you don't get the benefits of having a home for Ioke, which in some cases be inconvenient. Ioke can be run directly from the jar-file, though.</p>

                    <div class="section">
                      <h4><a name="runningScripts">Running scripts</a></h4>
                      <p>To run an Ioke script, you can generally just use the ioke-command:</p>
                      <pre class="code">
$ ioke helloWorld.ik
Hello world
                      </pre>

                      <p>You can also execute snippets of code on the command line using the -e argument to the ioke-command. You can have several of these one the same line too:</p>

                      <pre class="code">
$ ioke -e'"Hello world" println' -e'"Goodbye world" println'
Hello world
Goodbye world
                      </pre>

                      <p>When using -e, be careful about what quoting style you use, since the shell sometimes can munge up your commands if you don't surround them correctly.</p>
                      <p>The ioke command has several helpful command line options, that can change what happens during execution. These are:</p>
                      <dl>
                        <dt>-Cdirectory</dt>
                        <dd>Switch to directory before executing any files and command line scripts. This will make the directory the initial current working directory for Ioke during the execution of the JVM.</dd>

                        <dt>-d</dt>
                        <dd>Enable debug output.</dd>

                        <dt>-e script</dt>
                        <dd>Execute script, as describe above. May occur more than once on a command line.</dd>

                        <dt>-h</dt>
                        <dt>--help</dt>
                        <dd>Display help information, including descriptions of these command line options.</dd>

                        <dt>-Idirectory</dt>
                        <dd>Add directory to the load path of Ioke. May occur more than once on a command line.</dd>

                        <dt>-JjvmOptions</dt>
                        <dd>Pass on options to the JVM. This can be used to change any runtime parameters that your JVM takes. May occur more than once. The options are provided directly after the -J, so if you want to change the maximum amount of memory used, you can do that writing -J-Xmx128M. </dd>

                        <dt>--copyright</dt>
                        <dd>Print copyright information and exit.</dd>

                        <dt>--version</dt>
                        <dd>Print version information and exit</dd>

                        <dt>--server</dt>
                        <dd>Run the JVM in server Hotspot mode</dd>

                        <dt>--client</dt>
                        <dd>Run the JVM in client Hotspot mode (the default)</dd>

                        <dt>--</dt>
                        <dd>Mark the end of options to the ioke script, anything after this is options that will be sent to the code running.</dd>
                      </dl>

                      <p>If you provide the name of a script file on the command line, it should come after all the arguments to the ioke script. Everything after the script will be added as data to the 'System programArguments' cell. You can use both one-line scripts with -e and specify a script file. If so, the script file will be run after the one-line scripts.</p>
                    </div>

                    <div class="section">
                      <h4><a name="interactive">Interactive mode</a></h4>

                      <p>If no code to execute has been specified to the ioke script, IIk - Interactive Ioke - will start. This is a REPL that allow the execution of arbitrary code at a shell that immediately displays the result. The main difference between running Ioke from a file and interactively, is that the interactive prompt will show a notice of the result of the last operation, after each execution. IIk will also invoke a debugger when a condition is encountered. This debugger gives you the possibility to closer inspect what happened. The final difference with IIk is that it does not execute code directly in Ground - which the top level inside an Ioke script will do. This difference is crucial, when considering namespacing issues.</p>

                      <p>IIk will try to use Readline through JLine if your platform supports it.</p>

                      <p>IIk will be more closely described in the section on it, <a href="#iik">here</a>, but just to give a glimpse, this is how a small session could look like:</p>
                      <pre class="code">
iik> "hello world" println
hello world
+> nil

iik> 10 * 20
+> 200

iik> 3/2
+> 3/2

iik> 3/2 + 3/2
+> 3

iik> 3/2 * 3    
+> 9/2

iik> foo = "hello"
+> "hello"

iik> foo
+> "hello"

iik> exit
Bye.
                      </pre>

                      <p>When you see the prompt "iik>", you know that IIk is waiting for input. The result of a computation is shown after the "+>" sigil. You can exit from IIk by calling either "exit" or "quit". There is also a restart named "quit" that can be invoked to quit IIk.</p>
                    </div>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="syntax">Syntax</a></h2>

                  <p>Ioke has no keywords or statements. Everything is an expression composed of a chain of messages. A piece of code is represented as a chain of messages that links to the next message. The result of one message will be the receiver of the next message, until a "." message is received. The "." message is a terminator that throws away the current receiver. A newline will serve as a "." message in the circumstances where it feels natural.</p>

                  <p>An informal BNF description of Ioke looks like this:</p>
                  <pre style="font-family: courier;">
    program       ::=  messageChain*
    messageChain  ::=  expression*
    expression    ::=  message | brackets | operator | literal | terminator
    message       ::=  Identifier ( "(" commated? ")" )?
    commated      ::=  expression+ ( "," expression+ )*
    brackets      ::=  ( "[" commated? "]" ) | ( "{" commated? "}" )
    literal       ::=  Text | Regexp | Number | Decimal
    terminator    ::=  "." | "\n"
    comment       ::=  ";" .* "\n"
                  </pre>

                  <p>What isn't visible here is that all whitespace -- except for newlines -- will work only as separators of messages, and is otherwise ignored. That means that message sending does not use the dot, as in most other languages. A phrase such as "foo().bar(quux(42)).baaz()" would be expressed as "foo() bar(quux(42)) baaz()", or more succinctly "foo bar(quux(42)) baaz" in Ioke.</p>

                  <p>All the types of literals are actually turned into a message to create that literal, so the canonical form of the message chain contains no literals, just a message to create that literal. Any message can have zero or more arguments given to it. Arguments are separated with comma. If there are no arguments to a message, the parenthesis can be left off, but they need to be there if there are arguments. Mostly any combination of characters can be used as an Identifier, with some exceptions.</p>

                  <p>There is also a syntactic element called operators, which are handled a bit differently from regular messages. Specifically, through the use of operator shuffling, operators can be used in infix, including having different precedence rules. Assignment is a specific form of operator which gets its own kind of shuffling. These are both described below.</p>

                  <p>The two forms of brackets will get turned into a canonical form. Surrounding comma-separated message chains with square brackets is the same as calling the method [], giving it those message chains as argument. So [foo, bar, quux] is exactly the same as [](foo, bar, quux). The same is true for curly brackets.</p>

                  <p>Comments start with semicolon and end at the first newline. They can be used mostly anywhere, except inside of literal texts. The hash sign followed by an exclamation mark is also a comment, to allow the shebang line in Unix scripts.</p>

                  <p>How and when the actual evaluation of messages happen depend on what kind the message type is. If it's inactive, the value reflecting that cell will be returned. If it's active, the cell will be activated and the result of that activation returned. How the activation depends on what kind of code the cell contains. The various kinds of code is described more closely in the chapter about <a href="#code">code</a>.</p>

                  <div class="section">
                    <h3><a name="literals">Literal values</a></h3>
                    <p>Ioke currently contains four different kinds of literals. There is a fifth quasi literal, that isn't exactly parsed as a literal, but will be evaluated differently based on its name. These literals are texts, regular expressions, integers and decimal numbers. Symbols are actually parsed as regular identifiers, but they are handled a bit differently during evaluation.</p>

                    <div class="section">
                      <h4><a name="literalText">Text</a></h4>
                      <p>A literal text in Ioke is what is generally called strings in most languages. As in most languages, text is written inside of double quotes. Any characters are valid inside of those double quotes. That includes newlines - so you can write a literal text that extends to several lines. There is no alternate syntax for text. As in most other languages, several escapes are valid inside of a text. Escapes are preceded by the backslash, and insert the character corresponding to the escape values. These escapes are:</p>

                      <dl>
                        <dt>\b</dt>
                        <dd>Inserts the bell character, that is represented in ASCII by the decimal value 8.</dd>

                        <dt>\e</dt>
                        <dd>Inserts the character that is represented in ASCII by the decimal value 27. This value is used for sending escape values to the TTYs in some operating systems.</dd>

                        <dt>\t</dt>
                        <dd>Inserts the TAB character - ASCII decimal 9.</dd>

                        <dt>\n</dt>
                        <dd>Inserts the newline character - ASCII decimal 10.</dd>

                        <dt>\f</dt>
                        <dd>Inserts the form feed character - ASCII decimal 12.</dd>

                        <dt>\r</dt>
                        <dd>Inserts the carriage return character - ASCII decimal 13.</dd>

                        <dt>\"</dt>
                        <dd>Inserts the double quote character - ASCII decimal 34.</dd>

                        <dt>\\</dt>
                        <dd>Inserts the backslash character - ASCII decimal 92.</dd>

                        <dt>\[newline]</dt>
                        <dd>Inserts nothing at all. Used to escape necessary newlines, without having them show up in the output text.</dd>

                        <dt>\#</dt>
                        <dd>Inserts a literal hash character - ASCII decimal 35.</dd>

                        <dt>\uABCD</dt>
                        <dd>Inserts the Unicode codepoint corresponding to the hexadecimal value of the four characters following the "u". All four hexadecimal characters need to be specified.</dd>

                        <dt>\7, \12, \316</dt>
                        <dd>Inserts the Unicode codepoint corresponding to the octal value of the one, two or three octal characters. The maximum value allowed is \377, and the minimum is obviously \0.</dd>
                      </dl>

                      <p>The parsing of text will generate a message with name "internal:createText". This message will get one argument that is the raw Java String corresponding to the text.</p>

                      <p>Ioke allows automatic interpolation of arbitrary values in the same manner as Ruby. It uses the same syntax for this, which is the #{} syntax inside a text. These can be nested in any way. The elements will be parsed and sent as arguments to the message with name "internal:concatenateText". So an Ioke text such as "foo bar#{flux} will #{1+2}" will generate the message internal:concatenateText("foo bar", flux, " will ", 1+(2), ""). As you can see, there is a small amount of waste in the way this is generated -- but the simple model makes it easy to understand. It's not guaranteed that this will remain the same, although the message will definitely remain.</p>

                      <p>Some examples:</p>
                      <pre class="code">
<span style="color: #0050a0;">"foo"</span>

<span style="color: #0050a0;">"flax \
mux"</span>

<span style="color: #0050a0;">"one two #{three} \b four"</span>
                      </pre>
                    </div>

                    <div class="section">
                      <h4><a name="literalRegexps">Regular expressions</a></h4>
                      <p>The regular expression syntax of Ioke is currently quite primitive, although the literal syntax is there. A literal regular expression in Ioke starts with a hash sign, a slash, the expression, a slash, and possibly some flags. A few examples might be in order here:</p>
                      <pre class="code">
<span style="color: #ff1493;">#//</span>

<span style="color: #ff1493;">#/foo/</span>

<span style="color: #ff1493;">#/fo+/x</span>
                      </pre>

                      <p>The first example is an empty regular expression. The second is an expression matching the word "foo". The third expression matches an "f" followed with one or more "o". It also allows extended regular expression syntax, due to the x flag. The flags supported in Ioke are o, x, p, n, i, u, m and s. The meaning of these match the meaning of corresponding Ruby flags. Regular expressions allow most of the same escapes as Ioke text. Specifically, these escapes are supported: b, t, n, f, r, /, \ and newline. Unicode and octal escapes also work.</p>

                      <p>Ioke regular expressions will be transformed into a call to internal:createRegexp. This message expects two Java strings, one with the actual pattern, and one with the flags.</p>
                    </div>

                    <div class="section">
                      <h4><a name="literalIntegers">Integers</a></h4>
                      <p>Ioke supports arbitrarily sized numbers. It also contains a numerical tower that can be more closely explored in the reference documentation. The numerical tower is based in Number. Number Real mimics Number. Number Rational mimics Number Real, and so does Number Decimal. Finally, Number Integer and Number Ratio both mimics Number Rational. The interesting parts of this tower is Number Integer, which corresponds to integers, Number Ratio, which is any ratio between two integers, and Number Decimal, which corresponds to decimal numbers. These are arbitrarily sized and exact. There are no floats or doubles in Ioke. There is also a potential place for Number Complex at the same layer as Number Real, although complex numbers are not currently implemented. There are also plans for implementing a unit system further down the line.</p>

                      <p>Literal integers can be written using either decimal or hexadecimal notation. Hexadecimal notation begins with 0x or 0X and are then followed by one or more hexadecimal letters. They can be either upper or lower case. A decimal literal number is written using one or more decimal letters, but nothing else.</p>

                      <p>There is no literal to create ratios - these can only be created by division of integers. Negative numbers have no literal syntax, but preceding a number with a minus sign will call the message - on the number and generate the negative value.</p>

                      <p>A literal integer will be transformed into a call to internal:createNumber, which takes one native Java String from which to create the number.</p>

                      <p>Some examples:</p>
                      <pre class="code">
<span style="color: #0050a0;">1234444444444444444444444444444444444444235234534534</span>

<span style="color: #0050a0;">0</span>

<span style="color: #0050a0;">0xFFFFF</span>
                      </pre>
                    </div>

                    <div class="section">
                      <h4><a name="literalDecimals">Decimals</a></h4>
                      <p>Literal decimal values can be written either using exponential notation, or using a decimal dot. A decimal dot notation can be combined with exponential notation. Exponential notation starts with a number or a decimal number, followed by lower or upper case E, followed by an optional sign, and then followed by one or more decimal letters. </p>

                      <p>A literal decimal will be transformed into a call to internal:createDecimal, which takes one native Java String from which to create the decimal.</p>

                      <p>Some examples:</p>
                      <pre class="code">
<span style="color: #0050a0;">0.0</span>

<span style="color: #0050a0;">1E6</span>

<span style="color: #0050a0;">1E-32</span>

<span style="color: #0050a0;">23.4445e10</span>
                      </pre>
                    </div>

                    <div class="section">
                      <h4><a name="literalSymbols">Symbols</a></h4>
                      <p>Symbols aren't exactly syntax, but they aren't exactly messages either. Or rather, they are messages that will evaluate to the symbol that represent themselves. Symbol is a kind in Ioke. There are two kinds of symbols - the first one is simple symbols that can be parsed as is. The second is symbols that can't be parsed as is. Symbols are preceeded by a colon and then directly followed by the symbol text. If it can't be parsed correctly, the value should be surrounded by quotes, and this will be turned into a call to the method :, which takes the text as argument. That means that you can actually get dynamic symbols by calling the : method.</p>

                      <p>Some examples:</p>
                      <pre class="code">
<span style="color: #7777d4;">:foo</span>

<span style="color: #7777d4;">:flaxBarFoo</span>

<span style="color: #7777d4;">:""</span>

<span style="color: #7777d4;">:"mux mex mox \n ::::::::"</span>
                      </pre>
                    </div>
                  </div>

                  <div class="section">
                    <h3><a name="operatorShuffling">Operator shuffling</a></h3>
                    <p>One exception to the way message handling works in Ioke is operators. All the so called operators in this section is possible to call directly in message passing position too -- but to make it possible to use them in a more natural way, the parsing step will handle them a bit differently, and then do a shuffling step that actually takes operator precedence into account. So all the common operators will generally work as you expect them too -- although I recommend adding parenthesis when something is possibly unclear.</p>
                    
                    <p>Ioke has a slightly larger amount of operators than most other languages. Most of these are currently unused, but they are certainly available for use for any purpose the programmer wants to use it for. Many adherents of other languages (Java, I'm looking at you) claim that operator overloading is evil. I don't believe that is true, seeing as how it works so well in Ruby, so Ioke instead allow you quite large freedom with regards to operators.</p>

                    <p>The precedence rules for regular operators can be found in the cell 'Message OperatorTable operators', which is a regular Dict that can be updated with new values. The new values will obviously not take effect until the current code has run, and a new parse is started.</p>

                    <p>At the time of writing, the available operators are these:</p>

                    <ul>
                      <li>&lt;=&gt;</li>
                      <li>&lt;=</li>
                      <li>&gt;=</li>
                      <li>&lt;</li>
                      <li>&gt;</li>
                      <li>===</li>
                      <li>==</li>
                      <li>!=</li>
                      <li>=~</li>
                      <li>!~</li>
                      <li>-</li>
                      <li>+</li>
                      <li>**</li>
                      <li>*</li>
                      <li>/</li>
                      <li>%</li>
                      <li>&amp;&amp;</li>
                      <li>&amp;</li>
                      <li>||</li>
                      <li>|</li>
                      <li>^</li>
                      <li>=&gt;</li>
                      <li>=&gt;&gt;</li>
                      <li>&lt;-&gt;</li>
                      <li>-&gt;</li>
                      <li>+&gt;</li>
                      <li>!&gt;</li>
                      <li>&lt;&gt;</li>
                      <li>&amp;&gt;</li>
                      <li>%&gt;</li>
                      <li>#&gt;</li>
                      <li>@&gt;</li>
                      <li>/&gt;</li>
                      <li>*&gt;</li>
                      <li>?&gt;</li>
                      <li>|&gt;</li>
                      <li>^&gt;</li>
                      <li>~&gt;</li>
                      <li>**&gt;</li>
                      <li>&amp;&amp;&gt;</li>
                      <li>||&gt;</li>
                      <li>$&gt;</li>
                      <li>-&gt;&gt;</li>
                      <li>+&gt;&gt;</li>
                      <li>!&gt;&gt;</li>
                      <li>&lt;&gt;&gt;</li>
                      <li>&amp;&gt;&gt;</li>
                      <li>%&gt;&gt;</li>
                      <li>#&gt;&gt;</li>
                      <li>@&gt;&gt;</li>
                      <li>/&gt;&gt;</li>
                      <li>*&gt;&gt;</li>
                      <li>?&gt;&gt;</li>
                      <li>&gt;&gt;</li>
                      <li>^&gt;&gt;</li>
                      <li>~&gt;&gt;</li>
                      <li>**&gt;&gt;</li>
                      <li>&amp;&amp;&gt;&gt;</li>
                      <li>||&gt;&gt;</li>
                      <li>$&gt;&gt;</li>
                      <li>...</li>
                      <li>..</li>
                      <li>&lt;&lt;</li>
                      <li>&gt;&gt;</li>
                      <li>or</li>
                      <li>nor</li>
                      <li>xor</li>
                      <li>and</li>
                      <li>nand</li>
                      <li>!</li>
                      <li>~</li>
                      <li>$</li>
                    </ul>

                    <p>And as mentioned above, all of these can be used for your own purpose, although some of them already have reserved meanings. This document will cover most of the used operators, while the rest can be found in the reference.</p>

                    <p>Since this operator shuffling happens, that also means that an Ioke program has a canonical inner form that can differ from the source text. When you use introspection of any kind, you will get back that canonical form which might not look exactly like you expected. Similarily, if you ask some code to print itself, it will use the canonical form instead of the operator skin. Macros that modify message chains should work against the canonical form, and nothing else.</p>

                    <p>What an operator does depends on the result of sending the message of that name to the receiver, just like regular messages. In fact, to Ioke there really isn't any difference, except that the parsing takes special notice about operators and assignment operators.</p>
                  </div>

                  <div class="section">
                    <h3><a name="assignmentShuffling">Assignment shuffling</a></h3>
                    <p>Much like with regular operators, assignment operators are subject to a kind of shuffling. This shuffling differs from regular operator shuffling, in that it will shuffle around two things - the left hand side and the right hand side. This is true for every assignment operator except for the unary ones, which will only reshuffle one message.</p>

                    <p>A few examples might make the translation easier to percieve. The first item is the readable form, while the second form is the canonical form:</p>
                    <pre class="code">
<span style="color: #b0c4de;">foo</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">1</span> <span style="color: #00bfff;">+</span> <span style="color: #0050a0;">2</span>
<span style="color: #00bfff;">=</span>(foo<span style="color: #006666;">,</span> <span style="color: #0050a0;">1</span> <span style="color: #00bfff;">+</span>(<span style="color: #0050a0;">2</span>))

<span style="color: #8b0000;">Ground</span> <span style="color: #b0c4de;">foo</span> <span style="color: #00bfff;">*=</span> <span style="color: #0050a0;">"text"</span>
<span style="color: #b0c4de;">Ground</span> <span style="color: #00bfff;">*=</span>(foo<span style="color: #006666;">,</span> <span style="color: #0050a0;">"text"</span>)

bar foo(<span style="color: #0050a0;">123</span>) <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
<span style="color: #b0c4de;">bar</span> <span style="color: #00bfff;">=</span>(foo(<span style="color: #0050a0;">123</span>)<span style="color: #006666;">,</span> <span style="color: #0050a0;">42</span>)

flux<span style="color: #00bfff;">++</span>
<span style="color: #00bfff;">++</span>(flux)
                    </pre>

                    <p>These examples show some more advanced details -- specifically the fact that assignment operators generally work on "places", not on names or cells. This will be more explored in the chapter on <a href="#assignment">assignment</a>. The important thing to notice from the above examples is that for most assignments two things will be rearranged. For the unary operators only one thing will be moved.</p>

                    <p>Just as with regular operators, the assignment operators have information in the 'Message OperatorTable' cell. The specific cell is 'Message OperatorTable assignOperators', and it matches an assignment operator to either the integer 1, or the integer 2. Everything with 1 will be matched as being unary assignment.</p>

                    <p>The currently available assignment operators are:</p>

                    <ul>
                      <li>=</li>
                      <li>++</li>
                      <li>--</li>
                      <li>+=</li>
                      <li>-=</li>
                      <li>/=</li>
                      <li>**=</li>
                      <li>*=</li>
                      <li>%=</li>
                      <li>&amp;=</li>
                      <li>&amp;&amp;=</li>
                      <li>|=</li>
                      <li>||=</li>
                      <li>^=</li>
                      <li>&lt;&lt;=</li>
                      <li>&gt;&gt;=</li>
                    </ul>

                    <p>Just as with regular operators, what an assignment operator does depend on what the result is from sending the message of that name to the receiver object, just like with any type of message.</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="executionModel">Execution model</a></h2>
                  <p>The way an Ioke program work is very simple. Everything executes based on two things. The first is the context, or the ground, and the second is the receiver. The first message sent in each message chain will have the ground as receiver. The default ground in Ioke source files is an object called Ground. This object is in the mimic chain for most regular objects created in Ioke, which means that things defined at the top level will generally be available in most objects. Inside of methods and blocks, the ground will be different. Exactly in what way is defined by the type of code executing.</p>

                  <p>Every message in a chain will be sent to the receiver of that message. That receiver is the result of the last message, or the current ground if there was no previous message, or if that previous message was a terminator. So Ioke code like "foo bar(flux bar) quux" involves 5 different messages.</p>

                  <ol>
                    <li><p>The message "foo" is sent to Ground, which is the current ground and also the default receiver.</p></li>
                    <li><p>The message "bar" is sent to the result of the "foo" message. The value returned will be activated.</p></li>
                    <li><p>The cell "bar" contains a method in this case, and that method expects one argument, so that forces evaluation of the arguments.</p></li>
                    <li><p>The message "flux" is sent to Ground, since it's the ground and there is no prior message inside of an argument list.</p></li>
                    <li><p>The message "bar" is sent to the result of the "flux" message.</p></li>
                    <li><p>The result of the "bar" message is used as the argument value given to the outside "bar" method.</p></li>
                    <li><p>The message "quux" is sent to the result of the initial "bar" message.</p></li>
                    <li><p>The result of the quux message is thrown away, unless this code is part of a larger piece of code.</p></li>
                  </ol>

                  <p>This description generally describes what happens in the case of this code. The more general control flow is this:</p>

                  <ol>
                    <li><p>A message is encountered</p></li>
                    <li><p>If the message is a symbol message, the corresponding symbol will be returned.</p></li>
                    <li><p>Otherwise the name of the message will be looked up in the receiver, or in the receivers mimics.</p></li>
                    <li><p>If the name is found and is not activatable, the value of that name (the cell) is returned.</p></li>
                    <li><p>If the name is found and is activatable, it will be activated, with the current ground, receiver and message sent to the activatable object.</p></li>
                    <li><p>If the name is not found, a second search is done for the name "pass". If a pass is found, use that instead of the name of the original message, and go back to 4.</p></li>
                    <li><p>If a pass is not found, signal a Condition Error NoSuchCell condition.</p></li>
                  </ol>

                  <p>Exactly what happens when an object is activated depends on what kind of code gets activated. It's really up to the method, block or macro to handle evaluation of arguments in any way it likes - including not evaluating them. For a description of the default models available, see the chapter on <a href="#code">code</a></p>
                </div>

                <div class="chapter">
                  <h2><a name="objects">Objects</a></h2>
                  <p>The object model of Ioke is quite simple. Everything in Ioke is an object that follow these same rules. An object is something with an identity. It can have zero or more mimics, and zero or more cells. An object can also have a documentation text. Some objects can have a native data component. This acts more or less like a hidden cell that contains information that can't be directly represented in Ioke - for example the actual text in a Text. Or the actual number in a Number. Or the actual regular expression in a Regexp. These objects are the core types that contain primitive information.</p>
                  <p>A cell is the main way of representing data in Ioke. A cell has a name and a value. Every value in Ioke is a cell - every time you send a message, a cell is looked up for the value of that cell. Cells can contain any kind of data. In other languages, cells are generally called properties or slots. They are quite close to instance variables that also can contain methods. Cells can be added and removed at any time during runtime.</p>

                  <p>A mimic could also be called the parent of the object. Ioke is a prototype based language, which means that there is no distinction between classes of objects, and the objects themselves. In fact, any object can be used as the class of a new object. The word for that is mimicking, since the word class loses it's meaning in this kind of language. It's most common for an object to mimic one other object, at least initially. It's impossible to create an object that doesn't mimic anything, but you can remove all mimics for an object after the fact. You can also add more mimics. This turns out to be useful to represent shared functionality in the manner of Ruby mixins, for example. The actual effect of a mimic is that when a cell can't be found in the current object, all mimics will be searched for that cell (depth-first). So all cells available in an objects mimic is available to the object too. This is the inheritance part of OOP.</p>

                  <p>In many places you will find the word Kind used. A Kind is by convention an object that is used primarily to use as a mimic for other objects. The convention is that kinds are named with an initial upper case letter, while everything else starts with a lower case letter. The assignment process of Ioke also uses this convention to automatically set a cell called "kind" on any object that gets assigned to a name matching this convention.</p>

                  <p>The rest of this chapter will discuss the kinds that are the basis of the object system.</p>

                  <div class="section">
                    <h3><a name="base">Base</a></h3>

                    <p>The kind called Base is the top of the mimic chain. It's not generally useful in itself as it only defines the bare minimum of cells to make it possible to add new cells to it, mimic it, and so on. But if you want an object that is possible to use but not include most of the other stuff, Base is place to begin. Be careful when defining methods in Base, since it doesn't have access to most of the namespace. In fact, it doesn't even know about its own name. Base can act as a kind of blank slate, if needed, but it's probably easier to just create a regular object and remove all mimics from it after the fact.</p>

                    <p>Base defines these cells:</p>
                    <dl>
                      <dt>kind</dt>
                      <dd>returns the kind of the object, which is "Base".</dd>

                      <dt>notice</dt>
                      <dd>returns the short notice of the object, which is "Base". Refer to <a href="#introspection">Introspection</a> for more information about notice.</dd>

                      <dt>=</dt>
                      <dd>Takes two values, the first a place and the second a value, and assigns the place named to that value. Refer to <a href="#assignment">Assignment</a> for more information about it.</dd>

                      <dt>==</dt>
                      <dd>Compares this object against the argument. Returns true if they are the same, otherwise false.</dd>

                      <dt>cell</dt>
                      <dd>Takes one argument that should be the name of a cell that exists, and returns the value of the cell unactivated.</dd>

                      <dt>cell=</dt>
                      <dd>Sets a cell to a specific value. Used to set cells that can't be set using the regular assignment model. Refer to <a href="#assignment">Assignment</a> for more information about it.</dd>

                      <dt>cell?</dt>
                      <dd>Takes one argument that should be the name of a cell to check if it exists in this objects mimic chain.</dd>

                      <dt>cellNames</dt>
                      <dd>Returns a List containing the names of all cells this object contains.</dd>

                      <dt>cells</dt>
                      <dd>Returns a Dict with all cells this object contains. The key is the name and the value is the cell value.</dd>

                      <dt>documentation</dt>
                      <dd>Returns the documentation text for this object, or nil if no documentation exists for it.</dd>

                      <dt>documentation=</dt>
                      <dd>Sets the documentation text for this object.</dd>

                      <dt>mimic</dt>
                      <dd>Returns a newly created object that has the receiver as mimic. This is the magic way of creation new objects in Ioke. It is also the <em>ONLY</em> way to do it.</dd>
                    </dl>

                    <p>All of these methods are described further in the reference.</p>
                  </div>

                  <div class="section">
                    <h3><a name="ground">Ground</a></h3>
                    <p>As mentioned above, Ground is the default ground/context for evaluation. Ground mimics Base and DefaultBehavior. Ground is also special in that this is the place where all top level kinds are defined. If you want to create a top level kind, you should put it in Ground. If you take a look in Ground, you will see that it contains cells for Text, Dict, List, Base, Origin, itself and many other. Ioke doesn't have any global state at all, but Ground is as close as it gets. Ground should in most cases not be mimicked directly.</p>
                  </div>

                  <div class="section">
                    <h3><a name="origin">Origin</a></h3>
                    <p>Origin should be the place where most objects in Ioke start from. It is specifically created to be the origin of objects. As such it doesn't contain many cells for itself, but it mimics Ground and has access to everything from Base, DefaultBehavior and Ground in that way. When adding new more or less global functionality, Origin is probably the best place to put it. Currently, the only cells Origin contains is for purposes of printing itself.</p>
                  </div>

                  <div class="section">
                    <h3><a name="defaultBehavior">DefaultBehavior</a></h3>
                    <p>DefaultBehavior is a mixin - meaning it should never be the sole mimic of an object. Mixins are generally not grounded in Base, and doesn't contain most of the things you would expect from an object. DefaultBehavior contain almost all the general methods you use when programming Ioke. It contains the internal methods to create values from literals, and most other functionality specified in this document. In short, DefaultBehavior is the work horse, and you should have a pretty good reason to not have it in the mimic chain of an object. Since Ground mimics DefaultBehavior, any object you create from Origin, will have DefaultBehavior in its mimic chain.</p>
                  </div>

                  <div class="section">
                    <h3><a name="nilTrueFalse">nil, true, false</a></h3>
                    <p>The three values nil, true and false are the only values that are considered kinds, even though they start with lower case letters. They are not like the other kinds in the other important way either - these values can not be mimicked, and you will get a condition if you try it. The reason is that Ioke's basic boolean system revolves around these values. It is not entirely certrain that these values will forever be the only boolean values, but for now they are. nil should be used to represent the absence of a value, including the absence of a reasonable return value. false is the quintessential false value, and true is the quintessential true value. The value true isn't strictly necessary since any value except for nil and false are true. This notion of truthness mimics Ruby. The cells nil, true and false are defined in Ground, and they can actually be overridden or changed - but I don't recommend it. I can guarantee lots of chaos and non-working programs from doing it. More info on how these values interact can be found in the section on <a href="#comparison">Comparison</a>.</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="assignment">Assignment</a></h2>
                  <p>Superficially, Ioke's assignment model is quite simple. But there exists some subtleties too. One of the main reasons for this is that assigning a cell that doesn't exist will create that cell. Where it gets created is different based on what kind of context the assignment happens in. The main difference here is between a method activation context, or a lexical block context.</p>

                  <p>Ioke also supports assignment of places, which makes assigning much more flexible. A third feature of Ioke assignment is that it will check for the existence of an assignment method before assigning a specific name. This chapter will make all these things clear, and show some examples.</p>

                  <p>Let's start with a small example of simple assignment:</p>
                  <pre class="code">
<span style="color: #0000cd;">foo</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
foo <span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
foo <span style="color: #b0c4de;">y</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">13</span>
foo <span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">+=</span> <span style="color: #0050a0;">2</span>
                  </pre>

                  <p>The first line creates a new Origin mimic, and then assigns that to the name foo. Since this code executes at the top level, "foo" will be a new cell created in Ground. The second line creates a new cell called "x" inside the "foo" object. It gets assigned the value 42. The third line creates a "y" cell, and the fourth line sends the += message, which will first call +, and then assign using =. So at the end of this program, "foo" will contain two cells: "x" with value 44, and "y" with value 13. As mentioned above, cells gets created the first time they are assigned to. If you need to create a cell in a specific object, just namespace it. For example, if you want to make sure that you create a cell in Ground, just do "Ground foo = 42".</p>

                  <p>Inside of a method, the situation is exactly the same. If you assign something, it will be assigned in the current context, which is the local activation context (meaning it's the place where local variables are available). There are two situations where this doesn't hold true. The first one is within the special method "do". This method will take any code as argument and execute that with the receiver of the "do" message as the ground/context of the code inside it. That means "do" is a good way to create new cells inside an object.</p>

                  <p>This is a bit academic, so lets take a look at an example of this:</p>
                  <pre class="code">
<span style="color: #0000cd;">Foo</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
<span style="color: #606060;">Foo</span> <span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #6495ed;">method</span>(
  <span style="color: #a52a2a;">;; this creates a local variable in the method activation
</span>  <span style="color: #b0c4de;">foo</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
)

<span style="color: #0000cd;">Foo</span> <span style="color: #00bfff;">=</span> <span style="color: #8b0000;">Origin</span> <span style="color: #6495ed;">mimic</span>
<span style="color: #606060;">Foo</span> <span style="color: #449900;">do</span>(
  <span style="color: #a52a2a;">;; this creates the cell foo inside of Foo
</span>  <span style="color: #b0c4de;">foo</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
)
                  </pre>

                  <p>Here you can see a method defined called x. This method will just create a new local cell, which means calling the method will not make any difference on its receiver at all. The call to "do" in contrast will immediately execute the code inside it, and this code will create the cell "foo" inside of "Foo".</p>

                  <p>The second exception to the general rule is when executing inside of a lexical context. A lexical context is basically established inside of a block, but can also be created transparently when sending code to a method. A lexical block will try to not create new cells. When you assign a cell without a specific place to assign it, a lexical block will first see if there is any cell with that name further out, and if so it will make the assignment there instead. Only when no such cell exists, a new cell will be created in the lexical context. This code shows this in action:</p>
                  <pre class="code">
<span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
<span style="color: #6495ed;">fn</span>(<span style="color: #b0c4de;">x</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">43</span><span style="color: #006666;">.</span> <span style="color: #b0c4de;">y</span> <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>) <span style="color: #449900;">call</span>
x <span style="color: #a52a2a;">;; =&gt; 42
</span>y <span style="color: #a52a2a;">;; =&gt; Condition Error NoSuchCell</span>
                  </pre>
                  
                  <p>The "fn" message creates a new lexical block. The chapter on <a href="#code">code</a> will talk more about this. But as you can see, this block assigns 43 to the cell "x", and 42 to the cell "y". But since the cell "y" doesn't exist, it will only be created inside the lexical context, while "x" exists outside, and will be assigned a new value instead. The basic ideas is that code like this should behave like you expect it to behave.</p>

                  <p>The canonical form of assignment is a bit different from the way you usually code Ioke. The section on the syntax of assignments talked a bit about this. Specifically, something like "foo = 42" will get translated into "=(foo, 42)". That also means that assignment is just regular method call, that can be overridden or removed just like any other method. And that is exactly how both lexical context, and local method context make it possible to have different logic here. This is true for all assignment operators.</p>
                  
                  <p>All assignment operators take as their first argument the place to assign to. This place will be unevaluated. Only the second argument to an assignment will be evaluated. In most cases, a place is the same thing as a cell name, but it doesn't have to be. Let's look at the case of assigning a cell with a strange name. Say we want to assign the cell with the no name. We can do it like this:</p>
                  <pre class="code">
<span style="color: #449900;">cell</span>(<span style="color: #0050a0;">""</span>) <span style="color: #00bfff;">=</span> <span style="color: #0050a0;">42</span>
                  </pre>

                  <p>What happens here is a bit subtle. Since the left hand side of the assignment takes arguments, the "=" method figures out that the assignment is not to a simple cell name, but to a place. The parsing step will change "cell("") = 42" into "=(cell(""), 42)". Notice here that the argument comes along into the specification of the place. When this happens, the assignment operatoer will not try to create or assign a cell - instead it will in this case call the method cell=. So "cell("") = 42" will ultimately end up being the same as "cell=("", 42)". This way of transforming the name work the same for all cases, so you can have as many arguments as you want to the place on the left hand side. The equals sign will be added to the method name, and a message will be sent to that instead.</p>
                  <p>This makes assignment of places highly flexible, and the only thing you need to do is to implement methods with the right names. This feature is used extensively in Lists and Dicts to make it easy to assign to specifix indexes. So, say we have a list called x. Then this code: "x[13] = 42" will be transformed into "x =([](13), 42)" which will in turn be transformed into "x []=(13, 42)". Ioke lists also has an at= method, so you can do "x at(13) = 42" which will call at=, of course.</p>

                  <p>The second transformation that might happen is that if you try to assign a cell that have an assigner, you will call that assigner instead of actually assigning a cell. So, for example, if you do "foo documentation = 42", this will not actually create or assign the cell "documentation". Instead it will find that Base has a cell called "documentation=", and instead send that message. So the prior code would actually be equivalent to "foo documentation=(42)".</p>

                  <p>All of these assignment processes together make it really easy to take control over assignment, while still making it very obvious and natural in most cases.</p>
                </div>

                <div class="chapter">
                  <h2><a name="controlFlow">Control flow</a></h2>
                  <p>Ioke has some standard control flower operators, like most other languages. In Ioke, all of these are regular method calls, though, and they can usually be implemented in terms of Ioke. This chapter will chiefly talk about comparisons, conditionals and iteration constructs.</p>

                  <div class="section">
                    <h3><a name="comparison">Comparison</a></h3>
                    <p>There are several comparison operators in Ioke, but the most important is called the spaceship operator. This operator is &lt;=&gt;. It takes one argument and returns -1, 0 or 1 depending on the ordering of the receiver and the argument. If the two objects can't be compared, it returns nil. If you implement this operator and mixin Mixins Comparing, you get the operators ==, !=, &lt;, &lt;=, &gt; and &gt;= implemented in terms of the spaceship operator. There are two other common operators in Ioke. The first ~=, which can also be called the match operator. It's only implemented for Regexp right now. The === operator also exists, but isn't implemented for most objects. This operator doesn't do much right now, but is planned to be the basis of a Ruby-like case-statement further down the line. The contract of comparison operators is that they should return a true value (not necessarily the true), if the comparison is true, and otherwise return either false or nil.</p>

                    <p>The contract for === should be matching or not matching. It is among other things used in Ranges to see if something is included in that range or not.</p>

                    <pre class="code">
iik&gt; 1 + 2 &lt; 4
+&gt; true

iik&gt; 3 + 2 &lt; 4
+&gt; false

iik&gt; "foo" &lt;=&gt; "fop"
+&gt; -1
                    </pre>
                  </div>

                  <div class="section">
                    <h3><a name="conditionals">Conditionals</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="iteration">Iteration</a></h3>
                    <p>TODO: write content</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="code">Code</a></h2>
                  <p>TODO: write content</p>

                  <div class="section">
                    <h3><a name="methods">Methods</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="macros">Macros</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="blocks">Blocks</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="messageChains">Message chains</a></h3>
                    <p>TODO: write content</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="introspection">Introspection and reflection</a></h2>
                  <p>TODO: write content</p>
                </div>

                <div class="chapter">
                  <h2><a name="importing">Importing</a></h2>
                  <p>TODO: write content</p>
                </div>

                <div class="chapter">
                  <h2><a name="coreKinds">Core kinds</a></h2>
                  <p>TODO: write content</p>

                  <div class="section">
                    <h3><a name="conditions">Conditions</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="text">Text</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="symbols">Symbols</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="numbers">Numbers</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="lists">Lists</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="dicts">Dicts</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="rangesAndPairs">Ranges and Pairs</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="enumerable">Enumerable</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="regexps">Regexps</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="filesystem">FileSystem</a></h3>
                    <p>TODO: write content</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="libraries">Libraries</a></h2>
                  <p>TODO: write content</p>

                  <div class="section">
                    <h3><a name="iik">IIk</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="ispec">ISpec</a></h3>
                    <p>TODO: write content</p>
                  </div>

                  <div class="section">
                    <h3><a name="dokgen">DokGen</a></h3>
                    <p>TODO: write content</p>
                  </div>
                </div>

                <div class="chapter">
                  <h2><a name="missing">What is missing</a></h2>
                  <p>TODO: write content</p>
                </div>

                <div class="chapter">
                  <h2><a name="futurePlans">Future plans</a></h2>
                  <p>TODO: write content</p>
                </div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    </div>
  </body>
</html>
