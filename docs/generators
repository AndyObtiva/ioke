Sequences
-----------------------------------

Names: Mixins Sequenced, and Sequence

A protocol - you need to implement a method that returns a new Sequence. Assume this method is called "seq".

each will have as an additional protocol that it will call "seq" if given no arguments.

Sequence = Origin mimic do(
  next = method()
  next? = method()
  reset! = method()

  mapped         = macro(Sequence Map          create(call))
  collected      = macro(Sequence Map          create(call))
  sorted         = macro(Sequence Sort         create(call))
  sortedBy       = macro(Sequence SortBy       create(call))
  folded         = macro(Sequence Fold         create(call))
  injected       = macro(Sequence Fold         create(call))
  reduced        = macro(Sequence Fold         create(call))
  filtered       = macro(Sequence Filter       create(call))
  selected       = macro(Sequence Filter       create(call))
  grepped        = macro(Sequence Grep         create(call))
  zipped         = macro(Sequence Zip          create(call))
  dropped        = macro(Sequence Drop         create(call))
  droppedWhile   = macro(Sequence DropWhile    create(call))
  rejected       = macro(Sequence Reject       create(call))

  each = method(
    ; implemented in terms of next and next?
  )

  mimic!(Mixins Enumerable)
)

Sequence Filter    = Sequence mimic do()
Sequence Map       = Sequence mimic do()
Sequence Sort      = Sequence mimic do()
Sequence SortBy    = Sequence mimic do()
Sequence Fold      = Sequence mimic do()
Sequence Grep      = Sequence mimic do()
Sequence Zip       = Sequence mimic do()
Sequence Drop      = Sequence mimic do()
Sequence DropWhile = Sequence mimic do()
Sequence Reject    = Sequence mimic do()

sequences are lazy. each will realize the sequence. all enumerable methods will realize the sequence.

The methods on sequences are methods that are similar to all the methods on Enumerable that can return a collection of things.
Typical examples are "map", "sort", "sortBy", "fold", "filter". These methods have counterparts on Sequence that return new Sequences that will lazily do the operation.

The actual method names will be changed. There are a few alternatives. sequenceMap is clunky. gen:map is also clunky.
The best alternatives are putting the method name in past tense:
  map    ->    mapped
  sort   ->    sorted
  fold   ->    folded
  filter ->    filtered

The other alternative is to add "By"
  map    ->    mapBy
  sort   ->    sortBy
  fold   ->    foldBy
  filter ->    filterBy
This has the disadvantage of overlapping with sortBy on Enumerable.

We can also combine past tense with "By":
  map    ->    mappedBy
  sort   ->    sortedBy
  fold   ->    foldedBy
  filter ->    filteredBy

This once again doesn't explain what to do with sortBy.

The final alternative is to use the word lazy:
  map    ->    mapLazy
  sort   ->    sortLazy
  fold   ->    foldLazy
  filter ->    filterLazy

  map    ->    lazyMap
  sort   ->    lazySort
  fold   ->    lazyFold
  filter ->    lazyFilter


I still prefer the past tense though.






Look at interaction with Enumerable and what happens when you mimic Sequence
Also:
 make versions of all methods that uses the seq method:

 Sequenced mapped = macro(x = self seq. call resendTo(x, :mapped))
