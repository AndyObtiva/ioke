
http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
http://jasani.org/2008/01/03/testing-haskell-with-quickcheck/
http://rushcheck.rubyforge.org/



Ideas:

- Separate library
use("icheck")

- Set properties at the same level as it's
- Creation methods inside of the library
- Composable
- DSL include guards



forAll(integer x, y,
      [x, y] max should >= [x, y] min)

forAll(integer x, text y, foobar z,
)

forEvery(integer x, where: x > 10,
   (x - 10) should > 0)

forEvery(integer x, integer y, where: x > y,
   [x,y] sort should == [y, x])

generators:
 any() - will use random amounts of generators
 oneOf(gen1, gen2, ...)
 oneOfFrequency(gen1 => 0.3, gen2 => 0.5, ...)
 int()
 nat()
 decimal()
 bool()
 kleene()
 gen..gen
 list(gen)
 gen => gen
 text()
 (gen, gen, ...)
 

propReverse = forAll(list(int) xs,
                 xs reverse reverse should == xs)





- Minimization



a_one = forAll([] sort should == [])
a_two = forAll(int x, [x] sort should == [x])

a_two check!
a_two check!(verbose: true)



falsing = forAll(int x, y,
            [x,y] sort should == [x,y])

falsing.check!
=> Falsifiable, after 3 tests:
[2, -1]

forAll(int x, y, trivial: x == y,
           [x,y] sort should == [y,x] sort)

forAll(int x, y, 
           classify(simple): x == y,
           classifyAs(close): (x - y) abs < 2,

           [x,y] sort should == [y,x] sort)

forAll(int x, y, 
           classify(simple) x == y,
           classifyAs(close) (x - y) abs < 2,

           [x,y] sort should == [y,x] sort)


- Have something that can use generator to create new generators:
foo = generator(int x, text y,
  Origin with(blah: x, foo: y))


list, set and dict generators can also use [], {} and #{}.


generators need to specify shrinking behavior as well as generating behavior.

Constants as generators for themselves
