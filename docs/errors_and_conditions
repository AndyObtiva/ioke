In Common Lisp 

error will first signal, and then call invoke-debugger. invoke-debugger will first report the condition and then if we're not interactive will just quit.


Errors and conditions, and surrounding functionality
----------------------------------------------------

ensure will make sure that outwards code will always run, no matter if a condition or anything like that is raised.
it's essentially like CL unwind-protect, Ruby ensure, and Java finally.

ensure(
        do something
        that might 
        cause problems
        ,
        recover
        ,
        recover some more
)


Object based system. Hierarchy:

 "Condition"
   "Condition Standard"
   "Condition Serious"
     "Error"
       "Error Standard"
   "Warning"

these are all available by doing:
  error!
  warning!
  signal!

where signal! is the most general, and error! and warning! are implemented using signal!

You can give signal! anything at all, although it generally should be something that mimics Condition



foo mimics?(Condition) => true || false




Something like cerror would be nice. Maybe continuableError("foo")





Restarts
--------

Restarts are mostly totally separate from conditions. The only place where they interact is for the test functionality that checks if something actually is applicable for a restart.
You can establish restarts with this:

x = restart(
          report: fn(s, "flubber" println),
          test: fn(c, c mimics?(Condition)),
          fn(v1, v2,
          "implementation of restart" println))

bind(
   restart(fork, fn(123)),
   restart(continue,
            report: fn(s, "flubber" println)
            fn(xx, doSomethingRealHere)),
   restart(withName, x)
   restart(report: fn(s, "something"),
   x,
     "do something that causes errors" println))

"bind" will probably be used for other things than restarts too.


Methods to work with dynamically established restarts:

findRestart(:continue)

invokeRestart(:withName)
invokeRestart(:withName, 123, "foo")

computeRestarts()
computeRestarts(Error)



invoking a restart is more or less akin to throwing an exception that will be caught by bind forms, check for restarts, or continue upwards



Handling conditions
-------------------

There are two ways of handling a condition. The way these work depend on the way signalling is used. Just like Common Lisp, you can catch conditions, and you can handle conditions.
catching implies unwinding of the stack - handling implies staying at the point in the dynamic scope. 
For regular conditions, unwinding only happens if there is a catch established - if not, flow control will continue. As an example, take this example from Common Lisp

(progn
  (signal "something")
  (format t "After"))

If this is the full program, this will print "After".

On the other hand, if you have this:

(handler-case
  (progn
    (signal "something")
    (format t "After"))
  (condition () nil))

The signal will actually do a non-local return at this point.

Compare that to 

(progn
  (error "something")
  (format t "After"))

This will never ever execute the lines after it.

The searching for handlers and cases is quite interesting in CL, and Ioke will have much the same things. I'll try to document them as well as possible.

"bind" is used for both handling and rescuing. It might look like this:

bind(
  rescue(Error FileNotFound, Error IO, fn(e, "got error =(" println)),
  handler(Warning, fn(w, "got warning: " print; w println)),

  doSomethingEvilHere
)


The handler might in many cases want to invoke restarts. Since these also generate non local control, that will abandon any current processing.
If the condition was signalled using signal!, it will continue to invoke handlers and rescues in an ever expanding dynamic scope. rescues stop this invocation since it actually transfers flow control.
handlers do not stop the expansion. this is obviously untrue for error! as a side effect of the required non local flow control.

As you can see, both rescue and handler can take more than one condition and execute if either matches.



Signaling conditions
--------------------

This is the easiest part. Conditions are signalled using:

signal!(datum, &args)
error!(datum, &args)
warning!(datum, &args)

where datum are mostly the same things as in Common Lisp, and args are the rest of the arguments that are passed to the creation function for a condition
