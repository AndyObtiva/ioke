
add "it" and jregex matching

= should check for "foo=" before calling assign, so you can do
  msg next = blah
 instead of setNext


3. rescue()
4. handle()
5. signal!, error!, warning!
6. create default hierarchy of conditions
7. change internals to use conditions
8. simple IO
9. read & eval
10. implement a basic debugger -- in Ioke

ADD Common Lisp style conditions - before it's too late
  exceptions
  conditions would be nice

- Eval as message on Message. Will eval in the callers environment
- read is message that returns a message chain, right through the parser, just like in Lisp
- think for real about pretty printer

iik - interactive Ioke

 each

 break
 continue
 return

- java integration things

- inspection
  cellNames    -> slotNames
  cellSummary  -> slotSummary

  inspect - on Origin
  asText on everything - good default on Origin  

doFile
doScript

 add Enumerable stuff

Ioke
 Runtime
 System
 Machine

cellMissing === doesNotUnderstand === method_missing === forward

mimics == protos

hashes


lower prio
----------

- call initialization on creation
 - defined in terms of aspects

Add freeze/thaw methods
Use LinkedHashMap for cells, to keep insert order.

Look seriously at "become"

Common Lisp style "format" for outputting list structures and so on, as in "~{xc ~}"

look at Io Locals for Context stuff...

autoimporter in the style of Io Importer
 -- something like forward

Remember, all should be utf16

- something that allows stacking of ground. maybe just a simple "System ground" that is an array. This is used inside of the REPL for example.

aspects:
 - before
 - after
 - surround

resend
super

add with() and from()
