
Stuff that should parse:

Empty string



7. change internals to use conditions
8. simple IO
9. read & eval
10. implement a basic debugger -- in Ioke

 -- think about adding Clojure-style metadata

- Eval as message on Message. Will eval in the callers environment
- read is message that returns a message chain, right through the parser, just like in Lisp
- think for real about pretty printer

iik - interactive Ioke

 each

 break
 continue
 return

- java integration things

- inspection
  cellSummary  -> slotSummary

doFile
doScript

 add Enumerable stuff

Ioke
 Runtime
 System
 Machine

mimics == protos


= should check for "foo=" before calling assign, so you can do
  msg next = blah
 instead of setNext

lower prio
----------

- call initialization on creation
 - defined in terms of aspects

Add freeze/thaw methods

Look seriously at "become"

Common Lisp style "format" for outputting list structures and so on, as in "~{xc ~}"

look at Io Locals for Context stuff...

autoimporter in the style of Io Importer
 -- something like forward

- something that allows stacking of ground. maybe just a simple "System ground" that is an array. This is used inside of the REPL for example.

aspects:
 - before
 - after
 - surround

resend
super


would it be interesting to have lexicalblocks be enumerable?

newCounter = method(
  x = 0
  fn(x ++. x))
x = newCounter
x take(10)
x take(3)


