Look seriously at "become"

Common Lisp style format for outputting list structures and so on

"kind" cell, like "type" in Io
when something is assigned to a name with a capital letter, check if it has "kind", otherwise set it. In those cases also set an enclosure pointer to the place it's being set as part of.


look at Io Locals for Context stuff...

autoimporter in the style of Io Importer
 -- something like forward

ADD Common Lisp style conditions - before it's too late
  exceptions
  conditions would be nice

- Eval as message on Message. Will eval in the callers environment
- read is message that returns a message chain, right through the parser, just like in Lisp
- think for real about pretty printer

Remember, all should be utf16

iik - interactive Ioke

- something that allows stacking of ground. maybe just a simple "System ground" that is an array. This is used inside of the REPL for example.

 each

 break
 continue
 return

- java integration things

- inspection
  cellNames    -> slotNames
  cellSummary  -> slotSummary
  cell         -> getSlot

  inspect - on Origin
  asText on everything - good default on Origin  

doFile
doScript

List each
 add Enumerable stuff

Ioke
 Runtime
 System
 Machine

aspects:
 - before
 - after
 - surround

- call initialization on creation
 - defined in terms of aspects

when invoking a method, create a Locals object, and also a self.
 use "context" in the same way as Io "call"
 context call sender == call sender

    call sender
    call message
    call activated
    call slotContext
    call target

cellMissing === doesNotUnderstand === method_missing === forward
resend
super

mimics == protos

code

if, ifTrue, ifFalse, ifNil, ifNotNil

allow @ and @@ as prefixes (that should be short cut for self in defaultmethod)

add with() and from()

lists
hashes
[] and {} and []= and {}= methods

.. and ... for ranges


------------------------------
