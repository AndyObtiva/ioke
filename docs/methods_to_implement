
1. lexical blocks: fn


ADD Common Lisp style conditions - before it's too late
  exceptions
  conditions would be nice

- Eval as message on Message. Will eval in the callers environment
- read is message that returns a message chain, right through the parser, just like in Lisp
- think for real about pretty printer

Maybe use @something as a shortcut for cell("something") ... might be good. and it works for setting and getting stuff too, actually, if @ is self

iik - interactive Ioke

 each

 break
 continue
 return

- java integration things

- inspection
  cellNames    -> slotNames
  cellSummary  -> slotSummary
  cell         -> getSlot

  inspect - on Origin
  asText on everything - good default on Origin  

doFile
doScript

List each
 add Enumerable stuff

Ioke
 Runtime
 System
 Machine

cellMissing === doesNotUnderstand === method_missing === forward

mimics == protos

lists
hashes
[] and {} and []= and {}= methods


lower prio
----------

- call initialization on creation
 - defined in terms of aspects

Add freeze/thaw methods
Use LinkedHashMap for cells, to keep insert order.

Look seriously at "become"

Common Lisp style "format" for outputting list structures and so on, as in "~{xc ~}"

look at Io Locals for Context stuff...

autoimporter in the style of Io Importer
 -- something like forward

Remember, all should be utf16

- something that allows stacking of ground. maybe just a simple "System ground" that is an array. This is used inside of the REPL for example.

aspects:
 - before
 - after
 - surround

when invoking a method, create a Locals object, and also a self.
 use "context" in the same way as Io "call"
 context call sender == call sender

    call sender
    call message
    call activated
    call slotContext
    call target

resend
super

if, ifTrue, ifFalse, ifNil, ifNotNil

allow @ and @@ as prefixes (that should be short cut for self in defaultmethod)

add with() and from()

.. and ... for ranges
