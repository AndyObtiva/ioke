
= should check for "foo=" before calling assign, so you can do
  msg next = blah
 instead of setNext

implement easy macro, and then simple stuff like "", with, and so on.



3. rescue()
4. handle()
5. signal!, error!, warning!
6. create default hierarchy of conditions
7. change internals to use conditions
8. simple IO
9. read & eval
10. implement a basic debugger -- in Ioke

ADD Common Lisp style conditions - before it's too late
  exceptions
  conditions would be nice

- Eval as message on Message. Will eval in the callers environment
- read is message that returns a message chain, right through the parser, just like in Lisp
- think for real about pretty printer

iik - interactive Ioke

 each

 break
 continue
 return

- java integration things

- inspection
  cellNames    -> slotNames
  cellSummary  -> slotSummary
  cell         -> getSlot

  inspect - on Origin
  asText on everything - good default on Origin  

doFile
doScript

List each
 add Enumerable stuff

Ioke
 Runtime
 System
 Machine

cellMissing === doesNotUnderstand === method_missing === forward

mimics == protos

hashes


lower prio
----------

- call initialization on creation
 - defined in terms of aspects

Add freeze/thaw methods
Use LinkedHashMap for cells, to keep insert order.

Look seriously at "become"

Common Lisp style "format" for outputting list structures and so on, as in "~{xc ~}"

look at Io Locals for Context stuff...

autoimporter in the style of Io Importer
 -- something like forward

Remember, all should be utf16

- something that allows stacking of ground. maybe just a simple "System ground" that is an array. This is used inside of the REPL for example.

aspects:
 - before
 - after
 - surround

when invoking a method, create a Locals object, and also a self.
 use "context" in the same way as Io "call"
 context call sender == call sender

    call sender
    call message
    call activated
    call slotContext
    call target

resend
super

if, ifTrue, ifFalse, ifNil, ifNotNil

add with() and from()

.. and ... for ranges
