

This is how integrated classes should work:
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

- integrate is called with one or more types
 - returns a Class-object that implements/extends all types
  - the class object implements a marker interface
  - the class object has a constructor that takes an IokeObject that is the real proxy of a specific integration instance
 - the constructor should take a proxy object and all the other arguments to one of the constructors - and there should be one constructor for each super constructor


- integrate returns a wrapped class instance ... 
 - when you call 'new' on this call instance, something specific happens:
  - first, mimic is called on the object
  - then call newInstance on the class, sending in the iokeobject
  - then set the actual object of the wrapper thingy to the instance of the class...
  - make sure it's registered first
  - and return the whole thing


  in fact, the returned thing should be a regular wrapped java object... and the integrated stuff should be EXACTLY the same, except that new should work a bit differently.

--------------------------------------------------


calling a JIW from Ioke
 should be possible exactly like regular Java objects
 introspection should work on these methods, of course, in the normal, important way.

calling a JIW from Java
 should only be possible using established protocol - existing methods on interfaces or classes.
 when a call like this happens it should first try to dispatch to the proxy and then if that doesn't work call a super method
 that means the proxy can ONLY have methods defined for those that should be overridden
 how do we verify this if the class is part of the regular hierarcy? is it possible? how can we make sure that a cell implemented to call from Ioke to Java won't be recursively invoked from Java?

 maybe we can just use cellPlace? and if the result of doing that is the JIW class itself, we know that we shouldn't recurse
 
defining Ioke methods on a JIW
 should work the same as defining cells. or should it?




--------------------------------------------------


fields should probably just be exposed using a namespacing to discourage use:

private String x;
  will give

field:x
field:x=

private final String y;
  will give

field:y



For private methods, do the same thing so it's obvious that they are private:

private void doSomethingEvil();
  will give

private:doSomethingEvil


this works for setters and getters too:

  private String getSomething();
  private void setSomething(String something);

  will give

private:something
private:something=




protected and public methods should probably just be open, to make it easy.







implement == to use equals
implement same? to use real ==

I think that during cell lookup there needs to be a check - isAppropriate? that allows the division between classes and objects to be respected in lookup.











How to refer to full class names?
   Foo
   java:util:HashMap
   xml:com:sun:blarg:Foo$Bar$Quux  ;; inner classes
   xml:com:sun:blarg:Foo Bar Quux  ;; inner classes

Importing:
  JavaGround#import

   import(java:util:HashMap)

 assignment works too:

   HMap = java:util:HashMap

The class referred is the real class.

Create new instances with new

   HMap new

To figure out:
 - how to call overloaded methods
 - args by name functionality?
 - how to send code to Java methods?
    maybe something like this:
      Thread new(Runnable: callSomeExpensiveThing)
      Thread new(run: callSomeExpensiveThing)
      Collections sort(list, fn(x, y, x <=> y))
      Collections sort(list, compareTo: (x, y, x <=> y))

 - how to see difference between fields and methods
 - how to implement interfaces
 - how to extend from Java classes in some way


 - add loads of good helpers to Java types




Code:
 all interfaces and classes are activatable, so you can create a new simple implementatino of Comparable by calling it:
   Comparable(x, y, y <=> x)

   Comparable(
     compareTo: fn(x,y, x<=>y),
     equals: fn(other, other == 1)
   )

 keyword arguments will use the paranamer approach











-----

Send in code to methods that take interfaces ... three variations:
 one:
   if we see a parenthesis with more than one argument, we know it's a code argument to coerce into an interface or abstract class:
 addActionListener((e, e source text = "blarg"))

 two:
   a method or lexical block can always be coerced into an interface:
 addActionListener(fn(e, e source text = "Blarg"))

 three:
   activating a java class/interface
 addActionListener(ActionListener(e, e source text = "Blarg"))
 addActionListener(ActionListener(onEvent: fn(e, e source text = "Blarg")))
